{"id":8350,"date":"2021-08-02T17:14:33","date_gmt":"2021-08-03T00:14:33","guid":{"rendered":"https:\/\/tungsten.io\/?p=8350"},"modified":"2023-07-25T13:59:21","modified_gmt":"2023-07-25T20:59:21","slug":"tungsten-fabric-architecture-an-overview","status":"publish","type":"post","link":"https:\/\/tungsten.io\/tungsten-fabric-architecture-an-overview\/","title":{"rendered":"Tungsten Fabric architecture\u2014an overview"},"content":{"rendered":"\n<p><strong><em>This is a contributed blog from LF Networking Member CodiLime. <\/em><\/strong><a href=\"https:\/\/codilime.com\/blog\/tungsten-fabric-architecture-an-overview\/\"><strong><em>Originally published here<\/em><\/strong>.<\/a><\/p>\n\n\n\n<p><strong>SDN or Software-Defined Networking is an approach to networking that enables the programmatic and dynamic control of a network. It is considered the next step in the evolution of network architecture. To implement this approach effectively, you will need a mature SDN Controller such as Tungsten Fabric. Read our blog post to get a comprehensive overview of Tungsten Fabric architecture.<\/strong><\/p>\n\n\n\n<h2 class=\"wp-block-heading\">What is Tungsten Fabric<\/h2>\n\n\n\n<p><a href=\"https:\/\/codilime.com\/tungsten-fabric\/\">Tungsten Fabric<\/a>&nbsp;(previously OpenContrail) is an open-source&nbsp;<a href=\"https:\/\/codilime.com\/glossary\/sdn-controller\/\">SDN controller<\/a>&nbsp;that provides connectivity and security for virtual, containerized or bare-metal workloads. It is developed under the umbrella of&nbsp;<a href=\"https:\/\/tungsten.io\/\">the Linux Foundation<\/a>. Since most of its features are platform- or device agnostic, TF can connect mixed VM-container-legacy stacks. What Tungsten Fabric sees is only a source and target API. The technology stack that TF can connect includes:<\/p>\n\n\n\n<ul>\n<li>Orchestrators or virtualization platforms (e.g. OpenShift, Kubernetes, Mesos or VMware vSphere\/Orchestrator)<\/li>\n\n\n\n<li>OpenStack (via a monolithic plug-in or an ML2\/3 network driver mechanism)<\/li>\n\n\n\n<li>SmartNIC devices<\/li>\n\n\n\n<li>SR-IOV clusters<\/li>\n\n\n\n<li>Public clouds (multi-cloud or hybrid solutions)<\/li>\n\n\n\n<li>Third-party proprietary solutions<\/li>\n<\/ul>\n\n\n\n<p>One of TF\u2019s main strengths is its ability to connect both the physical and virtual worlds. In other words, to connect in one network different workloads regardless of their nature. They can be Virtual Machines, physical servers or containers.<\/p>\n\n\n\n<p>To deploy Tungsten Fabric, you may need&nbsp;<a href=\"https:\/\/codilime.com\/network-professional-services\/\">Professional Services (PS)<\/a>&nbsp;to integrate it with your existing infrastructure and ensure ease of use and security.<\/p>\n\n\n\n<h2 class=\"wp-block-heading\">Tungsten Fabric components<\/h2>\n\n\n\n<p>The entire TF architecture can be divided into the&nbsp;<a href=\"https:\/\/codilime.com\/glossary\/control-plane\/\">control plane<\/a>&nbsp;and&nbsp;<a href=\"https:\/\/codilime.com\/glossary\/data-plane\/\">data plane<\/a>&nbsp;components. Control plane components include:<\/p>\n\n\n\n<ul>\n<li>Config\u2014managing the entire platform<\/li>\n\n\n\n<li>Control\u2014sending rules for network traffic management to vRouter agents<\/li>\n\n\n\n<li>Analytics\u2014collecting data from other TF components (config, control, compute)<\/li>\n<\/ul>\n\n\n\n<p>Additionally, there are two optional components of the Config:<\/p>\n\n\n\n<ul>\n<li>Device Manager\u2014managing underlay physical devices like switches or routers<\/li>\n\n\n\n<li>Kube Manager\u2014observing and reporting the status of Kubernetes cluster<\/li>\n<\/ul>\n\n\n\n<p>Data plane or compute components include:<\/p>\n\n\n\n<ul>\n<li>vRouter and its agents\u2014managing packet flow at the virtual interface vhost0 according to the rule defined in the control component and received using vRouter agents<\/li>\n<\/ul>\n\n\n\n<h2 class=\"wp-block-heading\">TF Config\u2014the brain of the platform<\/h2>\n\n\n\n<p>TF Config is the main part of the platform where network topologies are configured. It is the biggest TF component developed by the largest number of developers. In a nutshell, it is a database where all configurations are stored. All other TF components depend on the Config. The term itself has two meanings:<\/p>\n\n\n\n<ul>\n<li>VM where all containers are stored<\/li>\n\n\n\n<li>A container named \u201cconfig\u201d where the entire business logic is stored<\/li>\n<\/ul>\n\n\n\n<p>TF Config has two APIs: North API (provided by Config itself) and South API (provided by other control plane components). The first one is more important here because it is the API used for communication. The South API is used by Device Manager (also a part of TF and discussed later) and other tools.<\/p>\n\n\n\n<p>TF Config uses an intent-based approach. The network administrator does not need to define all conditions but only how the network is expected to work. Other elements are configured automatically. For example, you want to enable network traffic from one network to another. It is enough to define this intention, and all the magic is done under the hood.<\/p>\n\n\n\n<p>The schema transformer listens to the database to check if there is a new entry. When such an entry is added, it checks for lacking data and completes it using the Northbound API. In this way, network routings are created, a firewall is unblocked to enable the traffic to flow between these two networks, and the devices obtain all the data necessary to get the network up and running.&nbsp;<\/p>\n\n\n\n<p>An intent-based approach automates network creation. There are many settings that need to be defined when creating a new network, and it takes time to set up all of them. As a process, it is also error-prone. Using TF simplifies everything, as most settings are default ones and are completed automatically.<\/p>\n\n\n\n<p>When it comes to communication with Config, its API is shared via http. Alternatively, you can use a TF UI or cURL, a command line tool for file transfer with a URL syntax supporting a number of protocols including HTTP, HTTPS, FTP, etc. There is also a TF CLI tool.<\/p>\n\n\n\n<figure class=\"wp-block-image\"><img decoding=\"async\" src=\"https:\/\/d33wubrfki0l68.cloudfront.net\/2e290badcc110dcce6a0552dbc336d7aff19ec7a\/0799e\/img\/codilime_tungsten-fabric-config-with-openstack.png\" alt=\"Tungsten Fabric Config with OpenStack\" title=\"Fig 1. Tungsten Fabric Config with OpenStack\"\/><\/figure>\n\n\n\n<figure class=\"wp-block-image\"><img decoding=\"async\" src=\"https:\/\/d33wubrfki0l68.cloudfront.net\/ae5f2aa3d9d32d1df4f649baa05ea40cd4f30dff\/7e06b\/img\/codilime_tungsten_fabric_config_with_kubernetes.png\" alt=\"Tungsten Fabric Config with Kubernetes\" title=\"Fig 2. Tungsten Fabric Config with Kubernetes\"\/><\/figure>\n\n\n\n<p><\/p>\n\n\n\n<h2 class=\"wp-block-heading\">Managing physical devices with Device Manager<\/h2>\n\n\n\n<p>Device Manager is an optional component with two major functions. Both are related to fabric management, which is the management of underlay physical devices like switches or routers.<\/p>\n\n\n\n<p>First, it is responsible for listening to configuration events from the Config API Server and then for pushing required configuration changes to physical devices. Virtual Networks, Logical Routers and other overlay objects can be extended to physical routers and switches. Device Manager enables homogeneous configuration management of overlay networking across compute hosts and hardware devices. In other words, bare-metal servers connected to physical switches or routers may be a part of the same Virtual Network as virtual machines or containers running on compute hosts.<\/p>\n\n\n\n<p>Secondly, this component manages the life cycle of physical devices. It supports the following features:<\/p>\n\n\n\n<ul>\n<li>onboarding fabric\u2014detect and import brownfield devices<\/li>\n\n\n\n<li>zero-touch provisioning\u2014detect, import and configure greenfield devices<\/li>\n\n\n\n<li>software image upgrade\u2014individual or bulk upgrade of device software<\/li>\n<\/ul>\n\n\n\n<p>Today only Juniper\u2019s MX routers and QFX switches have&nbsp;<a href=\"https:\/\/github.com\/tungstenfabric\/tf-controller\/tree\/master\/src\/config\/device-manager\/device_manager\/plugins\/juniper\/\">an open-source plug-in<\/a>.<\/p>\n\n\n\n<h2 class=\"wp-block-heading\">Device Manager: under the hood<\/h2>\n\n\n\n<p>Device Manager reports job progress by sending UVEs (User Visible Entities) to the Collector. Users can retrieve job status and logs using the Analytics API and it\u2019s Query Engine. Device Manager works in full or partial mode. There can be only one active instance in the full mode. In this mode, it is responsible for processing events sent via RABBITMQ. It evaluates high-level intents like Virtual Networks or Logical Routers and translates them into a low-level configuration that can be pushed into physical devices. It also schedules jobs on the message queue that can be consumed by other instances running in partial mode. Those followers listen for new job requests and execute ansible scripts, which&nbsp; push the desired configuration to devices.<\/p>\n\n\n\n<p>Device Manager has the following components:<\/p>\n\n\n\n<ul>\n<li>device-manager\u2014translates high-level intents into a low-level configuration<\/li>\n\n\n\n<li>device-job-manager\u2014executes ansible playbooks, which configure routers and switches<\/li>\n\n\n\n<li>DHCP server\u2014in a zero-touch provisioning use case, physical device gets management IP address from a local DHCP server running alongside device-manager<\/li>\n\n\n\n<li>TFTP server\u2014in the zero-touch provision use case, this server is used to provide a script with the initial configuration<\/li>\n<\/ul>\n\n\n\n<h2 class=\"wp-block-heading\">Kube Manager<\/h2>\n\n\n\n<p>Kube Manager is an additional component launched together with other Tungsten Fabric SDN Controller components. It is used to establish communication between Tungsten Fabric and Kubernetes, and is essential to their integration. In a nutshell, it listens to the Kubernetes API server events such as creation, modification or deletion of k8s objects (pods, namespaces or services). When such an event occurs, Kube Manager processes it and creates, modifies or deletes an appropriate object in the Tungsten Fabric Config API. Tungsten Fabric Control will then find those objects and send information about them along to the vRouter agent. After that, the vRouter agent can finally create the correctly configured interface for the container.&nbsp;<\/p>\n\n\n\n<p>The following example should clarify this process. Let\u2019s say that an annotation is added to the namespace in Kubernetes, saying that the network in this namespace should be isolated from the rest of the network. Kube Manager gets the information about it and changes the setup of the TF object accordingly.<\/p>\n\n\n\n<h2 class=\"wp-block-heading\">Control<\/h2>\n\n\n\n<p>The Control component is responsible for sending network traffic configurations to vRouter agents. Such configurations are received from the Config\u2019s Cassandra database, which offers consistency, high availability and easy scalability. To represent the configuration and operational state of the environment, the IF-MAP (The Interface to Metadata Access Point) protocol is used. The control nodes exchange routes with one another using IBGP protocol to ensure that all control nodes have the same network state. Communication between Control and vRouter agents is done via Extensible Messaging and the Presence Protocol (XMPP)\u2014a communications protocol for message-oriented middleware based on XML. Finally, the Control communicates with gateway nodes (routers and switches) using the BGP protocol.<\/p>\n\n\n\n<p>TF Control works similarly to a hardware router. Control is a control plane component responsible for steering the data plane and sending the traffic flow configuration to vRouter agents. For their part, hardware routers are responsible for handling traffic according to the instructions they receive from the control plane. In TF architecture, physical routers and their agent services work alongside vRouters and vRouter agents, as Tungsten Fabric can handle both physical and virtual worlds.<\/p>\n\n\n\n<p>TF Control communicates with a vRouter using XMPP, which is equivalent to a standard BGP session, though XMPP carries more information (e.g. configurations). Still, thanks to its reliance on XMPP, TF Control can send network traffic configurations to both vRouters and physical ones\u2014the code used for communication is exactly the same.<\/p>\n\n\n\n<figure class=\"wp-block-image\"><img decoding=\"async\" src=\"https:\/\/d33wubrfki0l68.cloudfront.net\/78293605fc2e819777b61ebc74e950624e0ebc2b\/46b16\/img\/codilime_tungsten_fabric_control.png\" alt=\"Tungsten Fabric Control\" title=\"Fig. 3 Tungsten Fabric Control\"\/><\/figure>\n\n\n\n<p><\/p>\n\n\n\n<h2 class=\"wp-block-heading\">Analytics<\/h2>\n\n\n\n<p>Analytics is a separate TF component that collects data from other components (config, control, compute). The following data are collected:<\/p>\n\n\n\n<ul>\n<li>Object logs (concrete objects in the TF structure)<\/li>\n\n\n\n<li>System logs<\/li>\n\n\n\n<li>Trace buffers<\/li>\n\n\n\n<li>Flow statistics in TF modules<\/li>\n\n\n\n<li>Status of TF modules (i.e. if they are working and what their state is)<\/li>\n\n\n\n<li>Debugging data (if a required data collection level is enabled in the debugging mode)<\/li>\n<\/ul>\n\n\n\n<p>Analytics is an additional component of Tungsten Fabric. TF works fine without it using just its main components. It can even be enabled as an additional plugin long after the TF solution was originally deployed.<\/p>\n\n\n\n<p>To collect the data coming from other TF components, an original Juniper protocol called Sandesh is used. The name comes from&nbsp;<a href=\"http:\/\/sandesh.com\/\">an Indian newspaper in Gujarati language<\/a>. \u201cSandesh\u201d means \u201cmessage\u201d or \u201cnews\u201d. Analogically, the protocol is the messenger that brings news about the SDN.<\/p>\n\n\n\n<p>In the Analytics component, there are two databases. One is based on the Cassandra database and contains historical data: statistics, logs, TF data flow information. It is commonly used for Analytics and Config components. Cassandra is the database that allows you to write data quickly, but it reads data more slowly. It is therefore used to write and store historical data. If there is a need to analyze how TF deployment worked over a longer period of time, this data can be read. In practice, such a need does not occur very often. This feature is most often used by developers to debug a problem.<\/p>\n\n\n\n<p>The second database is based on the Redis database and collects UVE (User Visible Entities) such as information about existing virtual networks, vRouters, virtual machines and about their actual state (whether it\u2019s working or not). These are the components of the system infrastructure defined by users (in contrast to the elements created automatically under the hood by TF). Since the data about their state are dynamic, they are stored in the Redis database, which allows users to read them much more quickly than in the Cassandra database.&nbsp;<\/p>\n\n\n\n<p>All these TF components send data to the Collector, which writes them in either the Cassandra or Redis database. On the other side, there is an API Server which is sometimes called the Analytics API to distinguish it from the API Server, e.g. in the Config. This Analytics API provides a REST API for extracting data from the database.<\/p>\n\n\n\n<p>Apart from these, Analytics has one additional component, called QueryEngine. This is an indirect process taking a user query for historical data. The user sends an SQL-like query to the Analytics API (API Server) REST port. Then the query is sent to QueryEngine, which performs a database query in Cassandra and, via the Analytics API, sends the result back to the user.<\/p>\n\n\n\n<p>&nbsp;Figure 4 shows the Analytics Node Manager and Analytics Database Node Manager. In fact, there are many different node managers in the TF architecture that are used to monitor specific parts of the architecture and send reports about them. In our case, Analytics Node Manager monitors Collector, QueryEngine and API Server, while the Analytics Database Node Manager monitors databases in the Analytics component. In this way, Analytics also collects data on itself.<\/p>\n\n\n\n<figure class=\"wp-block-image\"><img decoding=\"async\" src=\"https:\/\/d33wubrfki0l68.cloudfront.net\/ed127b73f4599b0f2fb94db2feca0d26b6878792\/b3bb1\/img\/codilime_tungsten_fabric_analytics.png\" alt=\"Tungsten Fabric Analytics\" title=\"Fig. 4 Tungsten Fabric Analytics\"\/><\/figure>\n\n\n\n<p><\/p>\n\n\n\n<h2 class=\"wp-block-heading\">The VRouter forwarder and agent<\/h2>\n\n\n\n<p>This component is installed on all compute hosts that run the workload. It provides Integrated routing and bridging functions for network traffic from and between Virtual Machines, Containers and external networks. It applies network and security rules defined by the Tungsten Fabric controller. This component is not mandatory, but it is required for any use case with virtualized workloads.&nbsp;<\/p>\n\n\n\n<ul>\n<li>Agent<\/li>\n<\/ul>\n\n\n\n<p>The agent is a user-space application that maintains XMPP sessions with the Tungsten Fabric controllers. It is used to get VRF (Virtual Routing and Forwarding) and ACLs (Access Control Lists) that are derived from high-level intents like Virtual Networks. The agent maintains a local database of VRFs and ACLs. This component reports its state to the Analytics API by sending Sandesh messages with UVEs (User Visible Entities) with logs and statistics. It is responsible for maintaining the correct forwarding state in Forwarder. The agent also handles some protocols like DHCP, DNS or ARP.<\/p>\n\n\n\n<p>Communication with the forwarder is achieved with the help of a KSync module, which uses Netlink sockets and shared memory between the agent and the forwarder. In some cases, application and kernel modules also use the pkt0 tap interface to exchange packets. Those mechanisms are used to update the flow table with flow entries based on the agent\u2019s local data.<\/p>\n\n\n\n<ul>\n<li>Forwarder<\/li>\n<\/ul>\n\n\n\n<p>The forwarder performs packet processing based on flows pushed by the agent. It may drop the packet, forward it to the local virtual machine, or encapsulate it and send it to another destination.<\/p>\n\n\n\n<p>The forwarder is usually deployed as a kernel module. In that case, it is a software solution independent of NIC or server type. Packet processing in kernel space is more efficient than in user-space and provides some room for optimization. The drawback is that it can only be installed with a specific supported kernel version. For advanced users, modules for a different kernel version can be built. Default kernel versions are specified&nbsp;<a href=\"https:\/\/github.com\/tungstenfabric\/tf-packages\">here<\/a>.<\/p>\n\n\n\n<p>This kernel module is released as a docker image that contains a pre-built module and user-space tools. When this image is run, it copies binaries to the host system and installs the kernel module on the host (it needs to be run in privileged mode). After successful installation, a vrouter module should be loaded into the kernel (\u201clsmod | grep vrouter\u201d) and new tap interfaces pkt0 and vhost0 created. If problems occur, checking the kernel logs (\u201cdmesg\u201d) can help you arrive at a solution.<\/p>\n\n\n\n<p>The forwarder can also be installed as a userspace application that uses The Data Plane Development Kit (DPDK), which enables higher performance than the kernel module.<\/p>\n\n\n\n<ul>\n<li>Packet flow<\/li>\n<\/ul>\n\n\n\n<p>For every incoming packet from a VM, vRouter forwarder needs to decide how to process it. The options are DROP, FORWARD, MIRROR, NAT or HOLD. Information about what to do is stored in flow table entries. The forwarder is using packet headers to find a corresponding entry in the above-mentioned tables. With the first packet from a new flow, the entry might be empty. In that case, the vRouter forwarder sends this packet to the pkt0 interface, where the agent is listening. Using its local information about VRFs and ACLs, the agent pushes (using KSync and shared memory) a new flow to the forwarder and resends a packet. In other words, the vRouter forwarder doesn\u2019t have full knowledge of how to process every packet in the system so it cooperates with the agent to get that knowledge. It is because this process may take some time that the first packet sent through the vRouter may come with a visible delay.<\/p>\n\n\n\n<figure class=\"wp-block-image\"><img decoding=\"async\" src=\"https:\/\/d33wubrfki0l68.cloudfront.net\/ce7df33860634d6884826a143b59fff25354c849\/9bb3f\/img\/codilime_tungsten-fabric-compute-with-openstack.png\" alt=\"Tungsten Fabric Compute with OpenStack\" title=\"Fig. 5 Tungsten Fabric Compute with OpenStack\"\/><\/figure>\n\n\n\n<p><\/p>\n\n\n\n<figure class=\"wp-block-image\"><img decoding=\"async\" src=\"https:\/\/d33wubrfki0l68.cloudfront.net\/bb1cb15886dadd0311a7daf94482d72eab948af1\/f69c8\/img\/codilime_tungsten_fabric_compute_with_kubernetes.png\" alt=\"Tungsten Fabric Compute with Kubernetes\" title=\"Fig. 6 Tungsten Fabric Compute with Kubernetes\"\/><\/figure>\n\n\n\n<p><\/p>\n\n\n\n<h2 class=\"wp-block-heading\">Tungsten Fabric with OpenStack and Kubernetes\u2014an overview<\/h2>\n\n\n\n<p>To sum up, Figures 7 and 8 provide an overview of the TF integration with Openstack and Kubernetes, respectively.<\/p>\n\n\n\n<figure class=\"wp-block-image\"><img decoding=\"async\" src=\"https:\/\/d33wubrfki0l68.cloudfront.net\/66268e490e805fb49cfee8bea9e0da362f9bdd17\/31273\/img\/codilime_tungsten-fabric-with-openstack.png\" alt=\"Tungsten Fabric with Openstack\" title=\"Fig. 7 Tungsten Fabric with Openstack\"\/><\/figure>\n\n\n\n<p><\/p>\n\n\n\n<figure class=\"wp-block-image\"><img decoding=\"async\" src=\"https:\/\/d33wubrfki0l68.cloudfront.net\/b2f1d82056fa087b400a34859992f4e7f5fc36ff\/1af44\/img\/codilime_tungsten_fabric_with_kubernetes.png\" alt=\"Tungsten Fabric with Kubernetes\" title=\"Fig. 8 Tungsten Fabric with Kubernetes\"\/><\/figure>\n\n\n\n<p><\/p>\n","protected":false},"excerpt":{"rendered":"<p>This is a contributed blog from LF Networking Member CodiLime. Originally published here. SDN or Software-Defined Networking is an approach to networking that enables the programmatic and dynamic control of&#8230;<\/p>\n","protected":false},"author":455,"featured_media":0,"comment_status":"closed","ping_status":"closed","sticky":false,"template":"","format":"standard","meta":{"footnotes":""},"categories":[4,30,17,20,28],"tags":[58,57,59,56],"acf":[],"yoast_head":"<!-- This site is optimized with the Yoast SEO plugin v21.6 - https:\/\/yoast.com\/wordpress\/plugins\/seo\/ -->\n<title>Tungsten Fabric architecture\u2014an overview - Tungsten Fabric<\/title>\n<meta name=\"robots\" content=\"index, follow, max-snippet:-1, max-image-preview:large, max-video-preview:-1\" \/>\n<link rel=\"canonical\" href=\"https:\/\/tungsten.io\/tungsten-fabric-architecture-an-overview\/\" \/>\n<meta property=\"og:locale\" content=\"en_US\" \/>\n<meta property=\"og:type\" content=\"article\" \/>\n<meta property=\"og:title\" content=\"Tungsten Fabric architecture\u2014an overview - Tungsten Fabric\" \/>\n<meta property=\"og:description\" content=\"This is a contributed blog from LF Networking Member CodiLime. Originally published here. SDN or Software-Defined Networking is an approach to networking that enables the programmatic and dynamic control of...\" \/>\n<meta property=\"og:url\" content=\"https:\/\/tungsten.io\/tungsten-fabric-architecture-an-overview\/\" \/>\n<meta property=\"og:site_name\" content=\"Tungsten Fabric\" \/>\n<meta property=\"article:published_time\" content=\"2021-08-03T00:14:33+00:00\" \/>\n<meta property=\"article:modified_time\" content=\"2023-07-25T20:59:21+00:00\" \/>\n<meta property=\"og:image\" content=\"https:\/\/d33wubrfki0l68.cloudfront.net\/2e290badcc110dcce6a0552dbc336d7aff19ec7a\/0799e\/img\/codilime_tungsten-fabric-config-with-openstack.png\" \/>\n<meta name=\"author\" content=\"tungstenfabric\" \/>\n<meta name=\"twitter:card\" content=\"summary_large_image\" \/>\n<script type=\"application\/ld+json\" class=\"yoast-schema-graph\">{\"@context\":\"https:\/\/schema.org\",\"@graph\":[{\"@type\":\"WebPage\",\"@id\":\"https:\/\/tungsten.io\/tungsten-fabric-architecture-an-overview\/\",\"url\":\"https:\/\/tungsten.io\/tungsten-fabric-architecture-an-overview\/\",\"name\":\"Tungsten Fabric architecture\u2014an overview - Tungsten Fabric\",\"isPartOf\":{\"@id\":\"https:\/\/tungsten.io\/#website\"},\"datePublished\":\"2021-08-03T00:14:33+00:00\",\"dateModified\":\"2023-07-25T20:59:21+00:00\",\"author\":{\"@id\":\"https:\/\/tungsten.io\/#\/schema\/person\/9d1cee939f67e25cd95e3d6fd76ff3af\"},\"inLanguage\":\"en-US\",\"potentialAction\":[{\"@type\":\"ReadAction\",\"target\":[\"https:\/\/tungsten.io\/tungsten-fabric-architecture-an-overview\/\"]}]},{\"@type\":\"WebSite\",\"@id\":\"https:\/\/tungsten.io\/#website\",\"url\":\"https:\/\/tungsten.io\/\",\"name\":\"Tungsten Fabric\",\"description\":\"multicloud multistack SDN\",\"potentialAction\":[{\"@type\":\"SearchAction\",\"target\":{\"@type\":\"EntryPoint\",\"urlTemplate\":\"https:\/\/tungsten.io\/?s={search_term_string}\"},\"query-input\":\"required name=search_term_string\"}],\"inLanguage\":\"en-US\"},{\"@type\":\"Person\",\"@id\":\"https:\/\/tungsten.io\/#\/schema\/person\/9d1cee939f67e25cd95e3d6fd76ff3af\",\"name\":\"tungstenfabric\",\"image\":{\"@type\":\"ImageObject\",\"inLanguage\":\"en-US\",\"@id\":\"https:\/\/tungsten.io\/#\/schema\/person\/image\/\",\"url\":\"https:\/\/secure.gravatar.com\/avatar\/a057983b5736b3bd0d8d86035d10c0a2?s=96&d=mm&r=pg\",\"contentUrl\":\"https:\/\/secure.gravatar.com\/avatar\/a057983b5736b3bd0d8d86035d10c0a2?s=96&d=mm&r=pg\",\"caption\":\"tungstenfabric\"},\"url\":\"https:\/\/tungsten.io\"}]}<\/script>\n<!-- \/ Yoast SEO plugin. -->","yoast_head_json":{"title":"Tungsten Fabric architecture\u2014an overview - Tungsten Fabric","robots":{"index":"index","follow":"follow","max-snippet":"max-snippet:-1","max-image-preview":"max-image-preview:large","max-video-preview":"max-video-preview:-1"},"canonical":"https:\/\/tungsten.io\/tungsten-fabric-architecture-an-overview\/","og_locale":"en_US","og_type":"article","og_title":"Tungsten Fabric architecture\u2014an overview - Tungsten Fabric","og_description":"This is a contributed blog from LF Networking Member CodiLime. Originally published here. SDN or Software-Defined Networking is an approach to networking that enables the programmatic and dynamic control of...","og_url":"https:\/\/tungsten.io\/tungsten-fabric-architecture-an-overview\/","og_site_name":"Tungsten Fabric","article_published_time":"2021-08-03T00:14:33+00:00","article_modified_time":"2023-07-25T20:59:21+00:00","og_image":[{"url":"https:\/\/d33wubrfki0l68.cloudfront.net\/2e290badcc110dcce6a0552dbc336d7aff19ec7a\/0799e\/img\/codilime_tungsten-fabric-config-with-openstack.png"}],"author":"tungstenfabric","twitter_card":"summary_large_image","schema":{"@context":"https:\/\/schema.org","@graph":[{"@type":"WebPage","@id":"https:\/\/tungsten.io\/tungsten-fabric-architecture-an-overview\/","url":"https:\/\/tungsten.io\/tungsten-fabric-architecture-an-overview\/","name":"Tungsten Fabric architecture\u2014an overview - Tungsten Fabric","isPartOf":{"@id":"https:\/\/tungsten.io\/#website"},"datePublished":"2021-08-03T00:14:33+00:00","dateModified":"2023-07-25T20:59:21+00:00","author":{"@id":"https:\/\/tungsten.io\/#\/schema\/person\/9d1cee939f67e25cd95e3d6fd76ff3af"},"inLanguage":"en-US","potentialAction":[{"@type":"ReadAction","target":["https:\/\/tungsten.io\/tungsten-fabric-architecture-an-overview\/"]}]},{"@type":"WebSite","@id":"https:\/\/tungsten.io\/#website","url":"https:\/\/tungsten.io\/","name":"Tungsten Fabric","description":"multicloud multistack SDN","potentialAction":[{"@type":"SearchAction","target":{"@type":"EntryPoint","urlTemplate":"https:\/\/tungsten.io\/?s={search_term_string}"},"query-input":"required name=search_term_string"}],"inLanguage":"en-US"},{"@type":"Person","@id":"https:\/\/tungsten.io\/#\/schema\/person\/9d1cee939f67e25cd95e3d6fd76ff3af","name":"tungstenfabric","image":{"@type":"ImageObject","inLanguage":"en-US","@id":"https:\/\/tungsten.io\/#\/schema\/person\/image\/","url":"https:\/\/secure.gravatar.com\/avatar\/a057983b5736b3bd0d8d86035d10c0a2?s=96&d=mm&r=pg","contentUrl":"https:\/\/secure.gravatar.com\/avatar\/a057983b5736b3bd0d8d86035d10c0a2?s=96&d=mm&r=pg","caption":"tungstenfabric"},"url":"https:\/\/tungsten.io"}]}},"_links":{"self":[{"href":"https:\/\/tungsten.io\/wp-json\/wp\/v2\/posts\/8350"}],"collection":[{"href":"https:\/\/tungsten.io\/wp-json\/wp\/v2\/posts"}],"about":[{"href":"https:\/\/tungsten.io\/wp-json\/wp\/v2\/types\/post"}],"author":[{"embeddable":true,"href":"https:\/\/tungsten.io\/wp-json\/wp\/v2\/users\/455"}],"replies":[{"embeddable":true,"href":"https:\/\/tungsten.io\/wp-json\/wp\/v2\/comments?post=8350"}],"version-history":[{"count":0,"href":"https:\/\/tungsten.io\/wp-json\/wp\/v2\/posts\/8350\/revisions"}],"wp:attachment":[{"href":"https:\/\/tungsten.io\/wp-json\/wp\/v2\/media?parent=8350"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"https:\/\/tungsten.io\/wp-json\/wp\/v2\/categories?post=8350"},{"taxonomy":"post_tag","embeddable":true,"href":"https:\/\/tungsten.io\/wp-json\/wp\/v2\/tags?post=8350"}],"curies":[{"name":"wp","href":"https:\/\/api.w.org\/{rel}","templated":true}]}}