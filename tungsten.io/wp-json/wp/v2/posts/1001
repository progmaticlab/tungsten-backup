{"id":1001,"date":"2013-12-16T21:27:52","date_gmt":"2013-12-16T21:27:52","guid":{"rendered":"http:\/\/opencontrail.org\/?p=1001"},"modified":"2013-12-16T21:27:52","modified_gmt":"2013-12-16T21:27:52","slug":"the-importance-of-abstraction-the-concept-of-sdn-as-a-compiler","status":"publish","type":"post","link":"https:\/\/tungsten.io\/the-importance-of-abstraction-the-concept-of-sdn-as-a-compiler\/","title":{"rendered":"The importance of Abstraction. The concept of &#8220;SDN as a Compiler&#8221;."},"content":{"rendered":"<p style=\"text-align: justify;\">OpenContrail consists of two parts.\u00a0 One part is the virtual router (vRouter) which sits in the hypervisor of virtualized servers.\u00a0 The other part is a logically centralized SDN controller which provides north bound REST APIs for managing the network.<\/p>\n<p><!--more Read more...--><\/p>\n<p style=\"text-align: justify;\">The fact that the OpenContrail controller is logically centralized simplifies network management a lot.\u00a0 Instead of having to manage lots of discrete devices, you have a single point of management.\u00a0 (Whilst OpenContrail is <i>logically<\/i> centralized it is actually <i>physically<\/i> distributed: it is implemented as a cluster of nodes for high availability and scale-out.)<\/p>\n<p style=\"text-align: justify;\">But the <i>real<\/i> key advantage of OpenContrail is that it allows you to manage the network at a high level of abstraction.\u00a0 That is the topic of this blog post.<\/p>\n<p style=\"text-align: justify;\">What does this rather academic sounding statement &#8220;<i>management at a high level of abstraction<\/i>&#8221; really mean?<\/p>\n<p style=\"text-align: justify;\">Traditionally, when you want to deploy some complex scenario such as a Layer 3 Virtual Private Network (L3VPN) you have to configure lots and lots of stuff.\u00a0 You have to configure routing instances, route targets, route distinguishers, import and export policies, interfaces, BGP, RSVP, etc. etc. etc.\u00a0 All of these configuration statements are at a really low level of abstraction.\u00a0 Instead of telling the routers <i>what<\/i> it is you are trying to achieve, you are giving the routers an excruciatingly detailed description of <i>how<\/i> to achieve it.\u00a0 These configurations can become very complex and large; it is not uncommon to have hundreds or even thousands of configuration statements on each individual router.\u00a0 In fact, at large service providers I have seen routers which multiple <i>hundreds of thousands <\/i>of lines of configuration.\u00a0 I&#8217;m not exaggerating.<\/p>\n<p style=\"text-align: justify;\">Not so with OpenContrail.\u00a0 The north-bound REST APIs provided by OpenContrail expose concepts at a much higher level of abstraction.\u00a0 These are APIs at the service layer instead of the technology layer.\u00a0 You instruct OpenContrail <i>what<\/i> to do, rather than <i>how <\/i>to do it.<\/p>\n<p style=\"text-align: justify;\">Let&#8217;s give some concrete examples to illustrate this concept.\u00a0 Using combination of OpenContrail and OpenStack REST APIs calls you can do things such as:<\/p>\n<ul style=\"text-align: justify;\">\n<li>Create virtual networks.<\/li>\n<li>Create tenant Virtual Machines (VMs) and attach them to virtual networks.\u00a0 Virtual machines connected to the same virtual network can communicate with each other.<\/li>\n<li>Create policies and apply them at the boundary of two virtual networks.\u00a0 This allows virtual machines on different virtual networks to communicate with each other subject to the rules and constraints expressed in the policy.<\/li>\n<li>Create service virtual machines, also known as Virtual Network Functions (VNFs), such as for example a virtual firewall.\u00a0 Policies can force traffic to be steered through one or a sequence of service virtual machines.\u00a0 This is referred to as a service chaining.<\/li>\n<li>Connect virtual networks to physical networks or to bare metal servers through using a gateway router or switch.<\/li>\n<\/ul>\n<p style=\"text-align: justify;\">The following figure illustrates how the individual &#8220;Lego blocks&#8221; of virtual networks, virtual machines, policies, and gateways can be combined into some useful assembly.<\/p>\n<p style=\"text-align: center;\" align=\"center\"><img loading=\"lazy\" decoding=\"async\" class=\"alignnone size-full wp-image-5749\" src=\"http:\/\/www.opencontrail.org\/wp-content\/uploads\/2013\/12\/bruno_1216_blogpost_image1.png\" alt=\"bruno_1216_blogpost_image1\" width=\"609\" height=\"215\" data-id=\"5749\" \/><br clear=\"ALL\" \/> Figure 1: Service Layer Abstraction<\/p>\n<p style=\"text-align: justify;\">Two important observations on the north-bound REST APIs:<\/p>\n<ul style=\"text-align: justify;\">\n<li>All of these things can also be done through the Graphical User Interface (GUI) which is simply an application on top of the REST APIs.<\/li>\n<li>Upcoming release 1.03 OpenContrail will provide REST APIs which are compatible with Amazon Web Services (AWS) <a href=\"http:\/\/aws.amazon.com\/ec2\/\">Elastic Compute Cloud (EC2)<\/a> and <a href=\"http:\/\/aws.amazon.com\/vpc\/\">Virtual Private Cloud (VPC)<\/a>.\u00a0 This makes it easy to migrate workloads back and forth between a private cloud implemented with Contrail and a public cloud with AWS EC2 and VPC compatible APIs.<\/li>\n<\/ul>\n<p style=\"text-align: justify;\">Now, what does OpenContrail actually do under the hood to implement these service layer abstractions?\u00a0 Most users will say, <a href=\"http:\/\/www.youtube.com\/watch?v=GQ5ICXMC4xY\">as Clark Gable famously said in <i>Gone with the Wind<\/i><\/a>: &#8220;Frankly, my dear, I don&#8217;t give a damn.&#8221;\u00a0 This is the beauty of OpenContrail.\u00a0 It allows users to manage their network at a high level of abstraction, using only concepts like virtual networks, virtual machines, policies and gateways.\u00a0 When we say manage, we don&#8217;t only mean configuration but also operational state and analytics.\u00a0 Most users neither care nor need to know how things actually work under the hood.<\/p>\n<p style=\"text-align: justify;\">The nice thing about having a high level of abstraction is that it allows users to create virtual networks and to interconnect virtual networks with policies without needing a deep knowledge of networking.\u00a0 This is not just a nice benefit for operators &#8211; it is a crucial requirement for allowing cloud tenant to self-manage their own virtual networks.<\/p>\n<p style=\"text-align: justify;\">That said, some small minority of people, e.g. the network operations team, does care and does need to know.<\/p>\n<p style=\"text-align: justify;\">These abstractions can be implemented in multiple ways.\u00a0 For example, historically data centers have used VLANs to implement virtual networks.\u00a0 And in Research and Education (R&amp;E) environments it is popular to use OpenFlow for what is typically called network slicing in those environments.<\/p>\n<p style=\"text-align: justify;\">For various scaling and stability reasons (which are explained in the white paper <a href=\"http:\/\/www.juniper.net\/us\/en\/local\/pdf\/whitepapers\/2000515-en.pdf\">&#8220;Proactive Overlay versus Reactive Hop-by-Hop &#8211; Juniper&#8217;s Motivations for the Contrail Architecture Explained.&#8221;<\/a>) the industry as a whole is converging on using &#8220;proactive overlays&#8221; for network virtualization in large scale deployments.\u00a0 There is an <a href=\"http:\/\/www.youtube.com\/watch?v=e_hqDFUOTTw\">excellent tutorial on overlay networking by Ivan Pepelnjak<\/a> on YouTube. (Gratuitous plug: Ivan also runs the <a href=\"http:\/\/www.ipspace.net\">ipspace.net<\/a> website where you can follow his blog posts and <a href=\"http:\/\/www.ipspace.net\/Subscription_to_ioshints_webinars\">subscribe to all of his truly excellent webinars<\/a> &#8211; at just under $200 per year it is an excellent value and highly recommended.)<\/p>\n<p style=\"text-align: justify;\"><br clear=\"ALL\" \/> In order to implement the service layer abstractions shown in figure 1 above, the OpenContrail SDN controller uses XMPP to communicate with virtual routers (vRouters) and uses BGP to communicate with physical gateway routers and switches.\u00a0 The OpenContrail SDN controller creates all the right routing instances in the right places, creates all the right overlay tunnels in the right places, puts all the right routes in the right forwarding tables, etc. etc. etc. to implement the required service layer abstractions.\u00a0 This is illustrated in the following figure.<\/p>\n<p align=\"center\"><img loading=\"lazy\" decoding=\"async\" class=\"alignnone size-full wp-image-5750\" src=\"http:\/\/www.opencontrail.org\/wp-content\/uploads\/2013\/12\/bruno_1216_blogpost_image2.png\" alt=\"bruno_1216_blogpost_image2\" width=\"485\" height=\"583\" data-id=\"5750\" \/><\/p>\n<p align=\"center\">Figure 2: Technology Layer Implementation<\/p>\n<p style=\"text-align: justify;\">Even though this example only contains a handful of servers, virtual machines, and gateways, it is already starting to look like a bowl of spaghetti.\u00a0 Just imagine what this diagram would have looked like if we had thousands of servers and tens of thousands of virtual machines.\u00a0 It would be a nightmare to configure that manually.<\/p>\n<p style=\"text-align: justify;\">But that&#8217;s exactly what we used to do before automation and SDN. Before SDN introduced logically centralized APIs at a high level of abstraction, we used to configure networks at this low level of abstraction.\u00a0 Now, with OpenContrail, all of this complexity gets automatically created under the hood.\u00a0 The only thing you need to do is to instantiate the service layer abstractions as shown in figure 1.<\/p>\n<p style=\"text-align: justify;\">What&#8217;s the magic in OpenContrail that achieves this?\u00a0 How is OpenContrail able to figure out how to translate the high level abstractions into low level operations on the network?<\/p>\n<p style=\"text-align: justify;\">OpenContrail uses a combination of formal data models and a transformation engine to accomplish this.\u00a0 This is illustrated in figure 3 below.<\/p>\n<p><img loading=\"lazy\" decoding=\"async\" class=\"size-full wp-image-5751 aligncenter\" src=\"http:\/\/www.opencontrail.org\/wp-content\/uploads\/2013\/12\/bruno_1216_blogpost_image3.png\" alt=\"bruno_1216_blogpost_image3\" width=\"564\" height=\"420\" data-id=\"5751\" \/><\/p>\n<p style=\"text-align: center;\"><span style=\"text-align: center;\">Figure 3: Data Models and Transformation Engine<\/span><\/p>\n<p style=\"text-align: justify;\">OpenContrail contains a data model which describes the high level service layer abstractions.\u00a0 This data model contains objects such as virtual networks, virtual machines, and policies.\u00a0 The objects in the service data model can be created, modified, deleted, and queried using north bound REST APIs.\u00a0 In fact, the north bound REST APIs are automatically generated from this data model.<\/p>\n<p style=\"text-align: justify;\">OpenContrail also contains another data model which describes the low level technology implementation details.\u00a0 Here we have objects such as routing instances, route targets, etc.<\/p>\n<p style=\"text-align: justify;\">Between the service data model and the technology data model sits a transformation engine.<\/p>\n<p style=\"text-align: justify;\">The transformation engine is responsible for translating the service data model to the technology data model.\u00a0 When you invoke the north bound REST APIs to instantiate a virtual network object in the service data model, the transformation engine wakes up and figures out &#8220;Hmmm&#8230;. you way you want a virtual network. That means I need to create these routing instances over here, and those overlay tunnels over there, and I need to put these routes in those routing instances.&#8221;\u00a0 The transformation engine then instantiates objects in the technology data model to represent the existence of those low level objects.<\/p>\n<p style=\"text-align: justify;\">At this point, nothing has actually happened yet in the network.\u00a0 The only thing we have done so far is that we have created a more detailed description of the desired state of the network.<\/p>\n<p style=\"text-align: justify;\">The south bound protocols fill this last remaining gap.\u00a0 These south bound protocols listen for changes in the technology data model and are responsible for &#8220;<a href=\"http:\/\/www.youtube.com\/watch?v=-ZxHAZChcYU\">making it so<\/a>&#8221; in the network.\u00a0 There are multiple south bound protocols, each responsible for particular subsets of the technology data model.\u00a0 For example, the XMPP south bound protocol is responsible for populating routes in virtual routers whereas the BGP south bound protocol is responsible for populating routes in physical gateway routers and switches.<\/p>\n<p style=\"text-align: justify;\">The above description is somewhat idealized and simplified.\u00a0 In reality we can have a hierarchy of multiple layers of abstractions.\u00a0 Each time something changes in the top layer of abstraction it percolates down the layers until it reaches the bottom of the hierarchy at which point the south bound protocols push it into the network.<\/p>\n<p style=\"text-align: justify;\">OpenContrail uses a publish subscribe (&#8220;pubsub&#8221;) <a href=\"http:\/\/en.wikipedia.org\/wiki\/IF-MAP\">IF-MAP<\/a> message bus to choreograph the sequence of events.\u00a0 Changes in the service data model generate events.\u00a0 The transformation engine subscribes to these events and executes transformation rules when these events occur.\u00a0 Those transformation rules make changes in the technology data model, which also generates events.\u00a0 Each south bound protocol subscribes to events for particular subsets of the technology data model.\u00a0 When those events occur, the relevant south bound protocol (e.g. XMPP or BGP) is woken up and it sends a message to the relevant network device to implement the change.<\/p>\n<p style=\"text-align: justify;\">The fact that OpenContrail uses a pubsub message bus is one of the reasons why it can massively scale out.\u00a0 Publishers and subscribers can be distributed across multiple nodes which communicate events with each other using the message bus.<\/p>\n<p style=\"text-align: justify;\">The OpenContrail uses the term &#8220;SDN as a Compiler&#8221; to describe this architecture.\u00a0 You can think of the service data model as a high level programming language (e.g. Java or Scala).\u00a0 You can think of the technology data model as a low level programming language (e.g. bytecode or assembly).\u00a0 You can think of the transformation engine as a compiler which is responsible for &#8220;compiling&#8221; the service data model into the technology data model.\u00a0 It&#8217;s a very fancy compiler though &#8211; it is an event-driven incremental Just In Time (JIT) compiler.<\/p>\n<p style=\"text-align: justify;\">Up until now we have described everything in terms of configuration.\u00a0 However, something similar happens in the reverse direction for operational state and analytics.\u00a0 The south bound protocols are responsible for collecting operational state and analytics events from the network.\u00a0 The transformation engine is responsible for correlating and aggregating these low level states and events into more meaningful information at the service layer.<\/p>\n<p style=\"text-align: justify;\">For example, the Contrail virtual routers (vRouters) generate analytics events for every individual flow in the network.\u00a0 The analytics nodes in the Contrail SDN controller contain collectors which store all of these events in a horizontally scalable distributed database.\u00a0 They also contain a query engine which allow you to ask service layer questions such as &#8220;what was the total amount of traffic from virtual network A to virtual network B between 9am and 10am this morning?&#8221;<\/p>\n<p style=\"text-align: justify;\">For some use cases it even makes sense for the transformation engine to take not just configuration state as input but also operational state.\u00a0 This creates feedback loops as shown in 3 above.<\/p>\n<p style=\"text-align: justify;\">For example, in a traffic engineering use case we combine the bandwidth demand matrix (high level configuration state), the administrative constraints (high level configuration state), the current topology of the network (high level operational state), and the current amount of traffic on the network (high level operational state) to compute a globally optimal set of paths e.g. LSPs (low level configuration state).\u00a0 Those LSPs are instantiated in the network using a south bound protocol (e.g. <a href=\"http:\/\/tools.ietf.org\/html\/rfc5440\">PCEP<\/a>).\u00a0 Other south bound protocols are responsible for collecting the operational state (e.g. <a href=\"https:\/\/datatracker.ietf.org\/doc\/draft-gredler-bgp-te\/\">BGP-TE<\/a> for topology discovery and netflow for traffic measurement).<\/p>\n<p style=\"text-align: justify;\">The current use cases implemented in Contrail don&#8217;t involve such feedback loops yet.\u00a0 When those uses cases are introduced we will get into some interesting control theory and stability questions.\u00a0 This would be a great area for academic research.<\/p>\n<p style=\"text-align: justify;\">One of key points to take away from all of this is that OpenContrail is not just a point product to solve a particular set of specific use cases such as network virtualization and service chaining.\u00a0 OpenContrail is actually a massively scalable framework for dynamic network management and control.<\/p>\n<p style=\"text-align: justify;\">We actively encourage the open source community to extend OpenContrail for other additional use cases by extending the high level data model with new types of services, by extending the low level data model with new types of technologies, by implementing new south bound protocols to push those new technology objects into the network, and by introducing new rules in the transformation engine.<\/p>\n<p style=\"text-align: justify;\">Here are some pointers into the OpenContrail code which is available in the<a href=\"https:\/\/github.com\/Juniper\/contrail-controller\"> Juniper\/contrail-controller Github repository<\/a> to get you started.<\/p>\n<p style=\"text-align: justify;\">The <a href=\"https:\/\/github.com\/Juniper\/contrail-controller\/tree\/master\/src\/schema\">src\/schema<\/a> directory contains all the data models, both the high level service data models and the low level technology data models.<\/p>\n<p style=\"text-align: justify;\">OpenContrail currently uses an XML-based data modeling language which is based on IF-MAP.\u00a0 The data models are stored in XML Schema Definition (XSD) files which contain additional annotations in the form of structured comments (referred to as IFMAP-SEMANTICS-IDL).\u00a0 The syntax and the semantics of those structured comments is described at the top of the file <a href=\"https:\/\/github.com\/Juniper\/contrail-controller\/blob\/master\/src\/schema\/vnc_cfg.xsd\">vnc_cfg.xsd<\/a>.<\/p>\n<p style=\"text-align: justify;\">As an example, here is an excerpt from the file <a href=\"https:\/\/github.com\/Juniper\/contrail-controller\/blob\/master\/src\/schema\/vnc_cfg.xsd\">vnc_cfg.xsd<\/a> which defines the virtual-machine object and the virtual-machine-interface object, and the relationship between them.<\/p>\n<p style=\"text-align: center;\" align=\"center\"><img loading=\"lazy\" decoding=\"async\" class=\"alignnone size-full wp-image-5753\" src=\"http:\/\/www.opencontrail.org\/wp-content\/uploads\/2013\/12\/bruno_1216_blogpost_image4.png\" alt=\"bruno_1216_blogpost_image4\" width=\"628\" height=\"186\" data-id=\"5753\" \/><\/p>\n<p style=\"text-align: center;\" align=\"center\">Figure 4: Example Data Model<\/p>\n<p style=\"text-align: justify;\">An earlier blog post by Pedro Marques titled &#8220;<a href=\"http:\/\/opencontrail.org\/adding-bgp-knob-to-opencontrail\/\">Adding a BGP knob to OpenContrail<\/a>&#8221; describes how to add a new element to the data model.<\/p>\n<p style=\"text-align: justify;\">The transformation engine rules are implemented as Python scripts in directory <a href=\"https:\/\/github.com\/Juniper\/contrail-controller\/tree\/master\/src\/config\/schema-transformer\">src\/config\/schema-transformer<\/a>.<\/p>\n<p style=\"text-align: justify;\">Each of the south bound protocols is stored in its own directory, for example directory <a href=\"https:\/\/github.com\/Juniper\/contrail-controller\/tree\/master\/src\/xmpp\">src\/xmpp<\/a> for XMPP and directory <a href=\"https:\/\/github.com\/Juniper\/contrail-controller\/tree\/master\/src\/bgp\">src\/bgp<\/a> for BGP.\u00a0 The main function for the controller node in file <a href=\"https:\/\/github.com\/Juniper\/contrail-controller\/blob\/master\/src\/control-node\/main.cc\">src\/control-node\/main.cc<\/a> instantiates the south bound protocols.<\/p>\n<p style=\"text-align: justify;\">Phew! You&#8217;ve made it to the end of this very long blog post.\u00a0 Hopefully you&#8217;ve learned something about the importance of having the right level of abstraction (namely a high level of abstraction) in the north bound interface provided by the SDN controller.\u00a0 This isolates the applications running on the network from the vendor specific implementation details.\u00a0 Using the concepts of transformation engines and &#8220;SDN as a Compiler&#8221; is not just elegant; it turns the SDN controller into a resilient, horizontally scalable, general purpose extensible platform for many current and future use cases.<\/p>\n","protected":false},"excerpt":{"rendered":"<p>OpenContrail consists of two parts.\u00a0 One part is the virtual router (vRouter) which sits in the hypervisor of virtualized servers.\u00a0 The other part is a logically centralized SDN controller which&#8230;<\/p>\n","protected":false},"author":467,"featured_media":0,"comment_status":"open","ping_status":"closed","sticky":false,"template":"","format":"standard","meta":{"footnotes":""},"categories":[5,10,1],"tags":[],"acf":[],"yoast_head":"<!-- This site is optimized with the Yoast SEO plugin v21.6 - https:\/\/yoast.com\/wordpress\/plugins\/seo\/ -->\n<title>The importance of Abstraction. The concept of &quot;SDN as a Compiler&quot;. - Tungsten Fabric<\/title>\n<meta name=\"robots\" content=\"index, follow, max-snippet:-1, max-image-preview:large, max-video-preview:-1\" \/>\n<link rel=\"canonical\" href=\"https:\/\/tungsten.io\/the-importance-of-abstraction-the-concept-of-sdn-as-a-compiler\/\" \/>\n<meta property=\"og:locale\" content=\"en_US\" \/>\n<meta property=\"og:type\" content=\"article\" \/>\n<meta property=\"og:title\" content=\"The importance of Abstraction. The concept of &quot;SDN as a Compiler&quot;. - Tungsten Fabric\" \/>\n<meta property=\"og:description\" content=\"OpenContrail consists of two parts.\u00a0 One part is the virtual router (vRouter) which sits in the hypervisor of virtualized servers.\u00a0 The other part is a logically centralized SDN controller which...\" \/>\n<meta property=\"og:url\" content=\"https:\/\/tungsten.io\/the-importance-of-abstraction-the-concept-of-sdn-as-a-compiler\/\" \/>\n<meta property=\"og:site_name\" content=\"Tungsten Fabric\" \/>\n<meta property=\"article:published_time\" content=\"2013-12-16T21:27:52+00:00\" \/>\n<meta property=\"og:image\" content=\"http:\/\/www.opencontrail.org\/wp-content\/uploads\/2013\/12\/bruno_1216_blogpost_image1.png\" \/>\n<meta name=\"author\" content=\"Bruno Rijsman\" \/>\n<meta name=\"twitter:card\" content=\"summary_large_image\" \/>\n<script type=\"application\/ld+json\" class=\"yoast-schema-graph\">{\"@context\":\"https:\/\/schema.org\",\"@graph\":[{\"@type\":\"WebPage\",\"@id\":\"https:\/\/tungsten.io\/the-importance-of-abstraction-the-concept-of-sdn-as-a-compiler\/\",\"url\":\"https:\/\/tungsten.io\/the-importance-of-abstraction-the-concept-of-sdn-as-a-compiler\/\",\"name\":\"The importance of Abstraction. The concept of \\\"SDN as a Compiler\\\". - Tungsten Fabric\",\"isPartOf\":{\"@id\":\"https:\/\/tungsten.io\/#website\"},\"datePublished\":\"2013-12-16T21:27:52+00:00\",\"dateModified\":\"2013-12-16T21:27:52+00:00\",\"author\":{\"@id\":\"https:\/\/tungsten.io\/#\/schema\/person\/29ba6d45ee3800b7016818b67e9aab2a\"},\"inLanguage\":\"en-US\",\"potentialAction\":[{\"@type\":\"ReadAction\",\"target\":[\"https:\/\/tungsten.io\/the-importance-of-abstraction-the-concept-of-sdn-as-a-compiler\/\"]}]},{\"@type\":\"WebSite\",\"@id\":\"https:\/\/tungsten.io\/#website\",\"url\":\"https:\/\/tungsten.io\/\",\"name\":\"Tungsten Fabric\",\"description\":\"multicloud multistack SDN\",\"potentialAction\":[{\"@type\":\"SearchAction\",\"target\":{\"@type\":\"EntryPoint\",\"urlTemplate\":\"https:\/\/tungsten.io\/?s={search_term_string}\"},\"query-input\":\"required name=search_term_string\"}],\"inLanguage\":\"en-US\"},{\"@type\":\"Person\",\"@id\":\"https:\/\/tungsten.io\/#\/schema\/person\/29ba6d45ee3800b7016818b67e9aab2a\",\"name\":\"Bruno Rijsman\",\"image\":{\"@type\":\"ImageObject\",\"inLanguage\":\"en-US\",\"@id\":\"https:\/\/tungsten.io\/#\/schema\/person\/image\/\",\"url\":\"https:\/\/secure.gravatar.com\/avatar\/c2f3989cc86672722a00756c482788e9?s=96&d=mm&r=pg\",\"contentUrl\":\"https:\/\/secure.gravatar.com\/avatar\/c2f3989cc86672722a00756c482788e9?s=96&d=mm&r=pg\",\"caption\":\"Bruno Rijsman\"},\"url\":\"https:\/\/tungsten.io\"}]}<\/script>\n<!-- \/ Yoast SEO plugin. -->","yoast_head_json":{"title":"The importance of Abstraction. The concept of \"SDN as a Compiler\". - Tungsten Fabric","robots":{"index":"index","follow":"follow","max-snippet":"max-snippet:-1","max-image-preview":"max-image-preview:large","max-video-preview":"max-video-preview:-1"},"canonical":"https:\/\/tungsten.io\/the-importance-of-abstraction-the-concept-of-sdn-as-a-compiler\/","og_locale":"en_US","og_type":"article","og_title":"The importance of Abstraction. The concept of \"SDN as a Compiler\". - Tungsten Fabric","og_description":"OpenContrail consists of two parts.\u00a0 One part is the virtual router (vRouter) which sits in the hypervisor of virtualized servers.\u00a0 The other part is a logically centralized SDN controller which...","og_url":"https:\/\/tungsten.io\/the-importance-of-abstraction-the-concept-of-sdn-as-a-compiler\/","og_site_name":"Tungsten Fabric","article_published_time":"2013-12-16T21:27:52+00:00","og_image":[{"url":"http:\/\/www.opencontrail.org\/wp-content\/uploads\/2013\/12\/bruno_1216_blogpost_image1.png"}],"author":"Bruno Rijsman","twitter_card":"summary_large_image","schema":{"@context":"https:\/\/schema.org","@graph":[{"@type":"WebPage","@id":"https:\/\/tungsten.io\/the-importance-of-abstraction-the-concept-of-sdn-as-a-compiler\/","url":"https:\/\/tungsten.io\/the-importance-of-abstraction-the-concept-of-sdn-as-a-compiler\/","name":"The importance of Abstraction. The concept of \"SDN as a Compiler\". - Tungsten Fabric","isPartOf":{"@id":"https:\/\/tungsten.io\/#website"},"datePublished":"2013-12-16T21:27:52+00:00","dateModified":"2013-12-16T21:27:52+00:00","author":{"@id":"https:\/\/tungsten.io\/#\/schema\/person\/29ba6d45ee3800b7016818b67e9aab2a"},"inLanguage":"en-US","potentialAction":[{"@type":"ReadAction","target":["https:\/\/tungsten.io\/the-importance-of-abstraction-the-concept-of-sdn-as-a-compiler\/"]}]},{"@type":"WebSite","@id":"https:\/\/tungsten.io\/#website","url":"https:\/\/tungsten.io\/","name":"Tungsten Fabric","description":"multicloud multistack SDN","potentialAction":[{"@type":"SearchAction","target":{"@type":"EntryPoint","urlTemplate":"https:\/\/tungsten.io\/?s={search_term_string}"},"query-input":"required name=search_term_string"}],"inLanguage":"en-US"},{"@type":"Person","@id":"https:\/\/tungsten.io\/#\/schema\/person\/29ba6d45ee3800b7016818b67e9aab2a","name":"Bruno Rijsman","image":{"@type":"ImageObject","inLanguage":"en-US","@id":"https:\/\/tungsten.io\/#\/schema\/person\/image\/","url":"https:\/\/secure.gravatar.com\/avatar\/c2f3989cc86672722a00756c482788e9?s=96&d=mm&r=pg","contentUrl":"https:\/\/secure.gravatar.com\/avatar\/c2f3989cc86672722a00756c482788e9?s=96&d=mm&r=pg","caption":"Bruno Rijsman"},"url":"https:\/\/tungsten.io"}]}},"_links":{"self":[{"href":"https:\/\/tungsten.io\/wp-json\/wp\/v2\/posts\/1001"}],"collection":[{"href":"https:\/\/tungsten.io\/wp-json\/wp\/v2\/posts"}],"about":[{"href":"https:\/\/tungsten.io\/wp-json\/wp\/v2\/types\/post"}],"author":[{"embeddable":true,"href":"https:\/\/tungsten.io\/wp-json\/wp\/v2\/users\/467"}],"replies":[{"embeddable":true,"href":"https:\/\/tungsten.io\/wp-json\/wp\/v2\/comments?post=1001"}],"version-history":[{"count":0,"href":"https:\/\/tungsten.io\/wp-json\/wp\/v2\/posts\/1001\/revisions"}],"wp:attachment":[{"href":"https:\/\/tungsten.io\/wp-json\/wp\/v2\/media?parent=1001"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"https:\/\/tungsten.io\/wp-json\/wp\/v2\/categories?post=1001"},{"taxonomy":"post_tag","embeddable":true,"href":"https:\/\/tungsten.io\/wp-json\/wp\/v2\/tags?post=1001"}],"curies":[{"name":"wp","href":"https:\/\/api.w.org\/{rel}","templated":true}]}}