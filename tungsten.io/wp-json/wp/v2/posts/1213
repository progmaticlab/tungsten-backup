{"id":1213,"date":"2014-01-23T08:56:25","date_gmt":"2014-01-23T08:56:25","guid":{"rendered":"http:\/\/opencontrail.org\/?p=1213"},"modified":"2014-01-23T08:56:25","modified_gmt":"2014-01-23T08:56:25","slug":"sandesh-a-sdn-analytics-interface","status":"publish","type":"post","link":"https:\/\/tungsten.io\/sandesh-a-sdn-analytics-interface\/","title":{"rendered":"Sandesh \u2013 A SDN Analytics Interface"},"content":{"rendered":"<p style=\"text-align: justify;\">In a previous blog posting titled \u201c<a href=\"http:\/\/opencontrail.org\/debugging-and-system-visibility-in-a-sdn-environment\/\">Debugging and System Visibility in a SDN Environment<\/a>\u201d, OpenContrail Software Engineer and my colleague, Anish Mehta, gave an overview of the challenges and opportunities facing SDN Analytics.<br \/>\n<!--more Read more...--> A SDN analytics solution needs to have the right abstractions, aggregation, and syncing mechanisms to report and present information that can be used by humans to operate a multi-tenant datacenter. Open APIs for both the northbound and the southbound analytics interface of the SDN controller are crucial to operate in a multi-vendor environment. The southbound interface here refers to the interface to gather information from both virtual and physical routers, gateways and network services appliances. Traditionally, the southbound interface consists of protocols like syslog, sFlow, netFlow, SNMP used by network elements to report information. Proprietary CLI commands generally display the current operational state of the network elements. OpenContrail Analytics node uses REST as the northbound interface and Sandesh as the southbound interface as shown below.<\/p>\n<p><a href=\"http:\/\/opencontrail.org\/wp-content\/uploads\/2014\/01\/sandesh_analytics_blogpost_picture.png\"><img loading=\"lazy\" decoding=\"async\" class=\"size-full wp-image-5744 aligncenter\" src=\"http:\/\/www.opencontrail.org\/wp-content\/uploads\/2014\/01\/sandesh_analytics_blogpost_picture.png\" alt=\"sandesh_analytics_blogpost_picture\" width=\"517\" height=\"500\" data-id=\"5744\" \/><\/a><\/p>\n<p style=\"text-align: center;\" align=\"center\"><strong>Figure 1: OpenContrail Analytics Node<\/strong><\/p>\n<p style=\"text-align: justify;\">In this blog post, we will present an overview of \u201cSandesh\u201d &#8211; A southbound interface protocol that is used by the OpenContrail Analytics engine to gather information from the OpenContrail virtual routers and other software modules like the control-node, and the configuration manager, which run as part of the controller. The name Sandesh comes from Sanskrit and means message. Sandesh consists of three components:<\/p>\n<p style=\"text-align: justify;\">1. An Interface Definition Language (IDL) and code generator based on <a href=\"http:\/\/thrift.apache.org\">Apache Thrift<\/a> that allows users\/developers to specify messages.<br \/>\n2. XML-based protocol that is used between the generators of the information and the collector of the information, which is the analytics engine<br \/>\n3. A back-end library used by the generators that integrates the generated code into an asynchronous queue based sending mechanism.<\/p>\n<p style=\"text-align: justify;\">The languages currently supported are C++, Python, and C. The C language support is limited to serialization and deserialization.<\/p>\n<p style=\"text-align: justify;\">The blog post will concentrate on the IDL and explain how the IDL allows the specification of abstractions, aggregation, and syncing mechanisms to be applied by the analytics engine to the messages defined in the IDL. The <a href=\"https:\/\/github.com\/Juniper\/contrail-sandesh\">Juniper \/contrail-sandesh<\/a> Github repository contains source code to help you get started. Readers interested in learning more about the XML-based protocol and the back-end library can look under the <a href=\"https:\/\/github.com\/Juniper\/contrail-sandesh\/tree\/master\/library\/cpp\/protocol\">library\/cpp\/protocol<\/a> for C++ and <a href=\"https:\/\/github.com\/Juniper\/contrail-sandesh\/tree\/master\/library\/python\/pysandesh\/protocol\">library\/python\/pysandesh\/protocol<\/a> for Python based implementation.<\/p>\n<h6 style=\"text-align: justify;\">Sandesh IDL and code generator:<\/h6>\n<p style=\"text-align: justify;\">The Sandesh code generator allows developers to define data types and messages to be sent to the analytics engine or the collector in a simple definition file. Taking that file as input, the code generator produces code to be used to send the messages to the collector. The code generator frees the developer from the burden of writing a load of boilerplate code to serialize and transport the objects to the collector. The developers are exposed a simple API to send the messages and the generated code along with the back-end library handles the grunt work of actually doing the low-level serialization\/deserialization and send\/receive. The data types supported in the IDL file are bool, byte, i16, i32, i64, string, list, map, struct, sandesh, u16, u32, u64, const static string. \u00a0The sandesh data-type is the top-level data type and identifies a unique message type being sent from the generator to the collector. Developers can define different types of sandesh based on the need to convey different types of information to the collector. Annotations are used in the IDL file to convey additional information like the abstraction to index the message against, aggregation mechanisms like sum, append, and union. For example, the annotation (key=&lt;Table-Name&gt;) is used to indicate that the message should be stored in a particular indexed table like the Virtual Network table in the analytics database.<\/p>\n<p style=\"text-align: justify;\">The sandesh code generator is used to transform the Sandesh IDL File (.sandesh) into source code, which is used by the generators. To generate the source from a sandesh file, user can run:<\/p>\n<pre style=\"text-align: justify;\"><span style=\"font-family: 'courier new', courier;\"><code>sandesh --gen &lt;language&gt; &lt;sandesh filename&gt;<\/code><\/span><\/pre>\n<p style=\"text-align: justify;\">For example, for a sandesh file \u2013 vns.sandesh, running\u00a0sandesh &#8211;gen cpp vns.sandesh produces the following auto-generated C++ code:<\/p>\n<pre style=\"text-align: justify;\"><span style=\"font-family: 'courier new', courier;\"><code>vns_types.h, vns_types.cpp, vns_constants.h, vns_constants.cpp, vns_html.cpp, vns_html_template.cpp\n vns_request_skeleton.cpp, vns.html, vns.xsl, vns.xml\n style.css<\/code><\/span><\/pre>\n<p style=\"text-align: justify;\">Similarly, running sandesh &#8211;gen py vns.sandesh produces the gen_py and vns python packages.\u00a0 Following files are auto-generated in the vns package:<\/p>\n<pre style=\"text-align: justify;\"><span style=\"font-family: 'courier new', courier;\"><code>ttypes.py, constants.py, http_request.py, vns.xml, vns.xsl, vns.html, request_skeleton.py, style.css, index.html<\/code><\/span><\/pre>\n<p style=\"text-align: justify;\">The source code for the sandesh code generator can be accessed under the <a href=\"https:\/\/github.com\/Juniper\/contrail-sandesh\/tree\/master\/compiler\">compiler\/<\/a> directory.<\/p>\n<h6 style=\"text-align: justify;\">Sandesh Types<\/h6>\n<p style=\"text-align: justify;\">Generators need to convey different types of information like system logs indicating occurrence of a system event, object state change information, statistics information, lightweight tracing needed for deep dive debugging, information to display current state of data structures. Developers can define different types of sandesh to address each of the above use cases.<\/p>\n<p style=\"text-align: justify;\">1. systemlog<br \/>\n<i>Use Case:<\/i><br \/>\nStructured log replacement for syslog.<br \/>\n<i>Example:<\/i><\/p>\n<pre style=\"text-align: justify;\"><span style=\"font-family: 'courier new', courier;\"><code>systemlog sandesh BgpPeerTableMessageLog {\n 1: string PeerType;\n 2: \"Peer\"\n 3: string Peer;\n 4: \"in table\";\n 5: string Table;\n 6: \":\";\n 7: string Message;\n }<\/code><\/span><\/pre>\n<p style=\"text-align: justify;\"><i>Notes:<\/i><\/p>\n<p style=\"text-align: justify;\">systemlog can optionally have a (key=\u201d&lt;Table-Name\u201d&gt;) annotation and this can be used to corelate logs across different network elements. For example, a (key=\u201dIPTable\u201d) can be used to corelate logs pertaining to a specific IP address across the physical routers and the virtual routers \/ SDN control plane. The const static strings defined in the message above \u2013 elements 2, 4, and 6 are only used for display purposes when querying the logs from the analytics database.<\/p>\n<p style=\"text-align: justify;\"><b>2. objectlog<\/b><\/p>\n<p style=\"text-align: justify;\"><i>Use Case:<\/i><\/p>\n<p style=\"text-align: justify;\">Logging state transitions and lifetime events for objects (VirtualMachine, VirtualNetwork). Objectlog is useful for performing historical state queries on an object. Objects have an object-id, which is indicated using the annotation (key=&#8221;&lt;Object-TableName&gt;&#8221;). For example, RoutingInstanceInfo below has name as the key.<\/p>\n<p style=\"text-align: justify;\"><i>Example:<\/i><\/p>\n<pre><span style=\"font-family: 'courier new', courier;\"><code> struct RoutingInstanceInfo {\n 1: string name (key=\"ObjectRoutingInstance\");\n 2: optional string route_distinguisher;\n 3: optional string operation;\n 4: optional string peer;\n 5: optional string family;\n 6: optional list&lt;string&gt; add_import_rt;\n 7: optional list&lt;string&gt; remove_import_rt;\n 8: optional list&lt;string&gt; add_export_rt;\n 9: optional list&lt;string&gt; remove_export_rt;\n 10: string hostname;\n }\n objectlog sandesh RoutingInstanceCollector {\n 1: RoutingInstanceInfo routing_instance;\n }<\/code><\/span><\/pre>\n<p style=\"text-align: justify;\"><i>Notes:<\/i><\/p>\n<p style=\"text-align: justify;\">It is best practice to add the <i>optional <\/i>keyword to elements whose values do not change frequently and thus do not need to be sent with each message.<\/p>\n<p style=\"text-align: justify;\"><b>3. uve\u00a0 (User Visible Entities)<\/b><\/p>\n<p style=\"text-align: justify;\"><i>Use Case:<\/i><\/p>\n<p style=\"text-align: justify;\">UVEs (User Visible Entities) are used represent the system-wide state of externally visible objects. uve is a special case of objectlog. UVEs are used to display the operational state of an object like VirtualMachine or VirtualNetwork, by aggregating information from uve sandesh messages across different generator types (configuration manager, virtual router, control node) and across nodes. uve like objectlog need the key annotation.<\/p>\n<p style=\"text-align: justify;\"><i>Details and Example:<\/i><\/p>\n<p style=\"text-align: justify;\">For example, consider the VirtualNetwork uve sandesh definition. We specify its state in two \u201ctiers\u201d \u2013 configuration manager and virtual router. \u00a0The configuration manager tier is defined in <a href=\"https:\/\/github.com\/Juniper\/contrail-controller\/blob\/master\/src\/config\/uve\/virtual_network.sandesh\">virtual_network.sandesh<\/a> in the src\/controller\/config\/uve directory and the virtual router tier is defined in <a href=\"https:\/\/github.com\/Juniper\/contrail-controller\/blob\/master\/src\/vnsw\/agent\/uve\/virtual_network.sandesh\">virtual_network.sandesh<\/a> in the src\/controller\/vnsw\/agent\/uve directory in the <a href=\"https:\/\/github.com\/Juniper\/contrail-controller\">Juniper\/contrail-controller<\/a> Github repository. For each tier, we return a single structure, even though a given virtual network might be present on many software modules in that tier. A VirtualNetwork might be present on many virtual routers; these virtual routers are expected to send uve sandesh messages when any attribute of the VirtualNetwork changes state. The virtual router tier of the VirtualNetwork UVE definition looks like:<\/p>\n<pre style=\"text-align: justify;\"><span style=\"font-family: 'courier new', courier;\"><code> struct UveInterVnStats {\n 1: string\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0other_vn (aggtype=\"listkey\")\n 2: i64\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0out_tpkts;\n 3: i64\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0in_tpkts;\n }\n struct UveVirtualNetworkAgent {\n 1: string\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 name(key=\"ObjectVNTable\")\n 2: optional bool deleted\n 3: optional i32\u00a0\u00a0total_acl_rules\n 4: optional i32\u00a0 total_analyzers(aggtype=\u201dsum\u201d)\n 5: optional i64\u00a0 in_tpkts\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 (aggtype=\"counter\")\n 7: optional i64\u00a0\u00a0out_tpkts\u00a0\u00a0\u00a0\u00a0\u00a0 (aggtype=\"counter\")\n 9: optional list&lt;UveInterVnStats&gt;stat(aggtype=\"append\")\n 11: optional list&lt;string&gt; vm_list (aggtype=\"union\")\n }\n uve sandesh UveVirtualNetworkAgentTrace {\n 1: UveVirtualNetworkAgent\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 data;\n }<\/code><\/span><\/pre>\n<p style=\"text-align: justify;\">UVEs are special case of Objectlog and hence each UVE has an object-id, which is denoted using the (key=&#8221;&lt;Object-TableName&gt;&#8221;) annotation.\u00a0 The annotation needs to consistent across all the tiers of the UVEs to allow correlation and aggregation to be performed by the analytics engine.<\/p>\n<p style=\"text-align: justify;\">The \u201caggtype\u201d annotation allows the developer to choose how the analytics engine should aggregate the attribute when sent across multiple generators and tiers. \u00a0For example, for the \u201caggtype=sum\u201d annotation on an attribute, the analytics engine reports an aggregate value that is a sum of the values sent by all generators. In the VirtualNetwork uve sandesh definition, each virtual router tracks the number of analyzer instances attached to a VirtualNetwork using the attribute \u201ctotal_analyzers\u201d. The aggregate value reported by the analytics engine should be a sum of the values of this attribute across all virtual routers on which the VirtualNetwork exists.<\/p>\n<p style=\"text-align: justify;\"><b>4. trace<\/b><\/p>\n<p style=\"text-align: justify;\"><i>Use Case:<\/i><\/p>\n<p style=\"text-align: justify;\">Light-weight in memory buffer logs for frequently occurring events<\/p>\n<p style=\"text-align: justify;\"><i>Example:<\/i><\/p>\n<pre style=\"text-align: justify;\"><span style=\"font-family: 'courier new', courier;\"><code> trace sandesh XmppRxStream {\n 1: \"Received xmpp message from: \";\n 2: string IPaddress;\n 3: \"Port\";\n 4: i32 port;\n 5: \"Size: \";\n 6: i32 size;\n 7: \"Packet: \";\n 8: string packet;\n 9: \"$\";\n }<\/code><\/span><\/pre>\n<p style=\"text-align: justify;\"><b>5. traceobject<\/b><\/p>\n<p style=\"text-align: justify;\"><i>Use Case:<\/i><\/p>\n<p style=\"text-align: justify;\">Light-weight in memory buffer logs for frequently occurring object state transitions<\/p>\n<p style=\"text-align: justify;\"><i>Example:<\/i><\/p>\n<pre><span style=\"font-family: 'courier new', courier;\"><code> traceobject sandesh RoutingInstanceCreate {\n 1: string name;\n 2: list&lt;string&gt; import_rt;\n 3: list&lt;string&gt; export_rt;\n 4: string virtual_network;\n 5: i32 index;\n }<\/code><\/span><\/pre>\n<p style=\"text-align: justify;\"><i>Notes about <\/i><i>trace<\/i><i> and <\/i><i>traceobject<\/i><i>:<\/i><\/p>\n<p style=\"text-align: justify;\">Developer needs to create a Sandesh Trace Buffer with a given size wherein the trace and traceobject sandesh are stored. HTTP introspect (explained in the request and response sandesh) can be used to request viewing of the trace buffer. Tracing to the buffer can be enabled or disabled, and multiple types of trace and traceobject sandesh can be traced into a single trace buffer.<\/p>\n<p style=\"text-align: justify;\"><b>6. request and response<\/b><\/p>\n<p style=\"text-align: justify;\"><i>Use Case:<\/i><\/p>\n<p style=\"text-align: justify;\">Request is used to send commands from requestor to generator. Response is used for response from generator to requestor. Request and response are used to dump internal data structures and provide operational information from the software modules needed for in-depth debugging.<\/p>\n<p style=\"text-align: justify;\"><i>Example:<\/i><\/p>\n<pre><span style=\"font-family: 'courier new', courier;\"><code> request sandesh SandeshLoggingParamsSet {\n 1: bool enable;\n 2: string category;\n 3: string level;\n }\n response sandesh SandeshLoggingParams {\n 1: bool enable;\n 2: string category;\n 3: string level;\n }<\/code><\/span><\/pre>\n<p style=\"text-align: justify;\"><i>Notes:\u00a0<\/i><i><\/i><\/p>\n<p style=\"text-align: justify;\">The developer is expected to provide the implementation of the request handling function. For the above example, in C++ it will be implementation of SandeshLoggingParamsSet::HandleRequest function and for python a bound method named handle_request is expected to be present in SandeshLoggingParamsSet.<\/p>\n<h6 style=\"text-align: justify;\">HTTP Introspect<\/h6>\n<p style=\"text-align: justify;\">Sandesh is also used to implement support for debugging in the OpenContrail controller and virtual router software modules. The debugging facility is called HTTP Introspect. The sandesh code generator produces HTML forms for each request sandesh and associated stylesheets that are required to render response sandesh when invoked with the \u2013gen html option. Each software module contains an embedded web\/HTTP server which developers can use to dump internal state of data structures, view trace messages, and perform other extensive debugging.<\/p>\n<p style=\"text-align: justify;\">For example, to debug the BGP neighbor peering status on the control-node, the developer has defined a request sandesh in <a href=\"https:\/\/github.com\/Juniper\/contrail-controller\/blob\/master\/src\/bgp\/bgp_peer.sandesh\">bgp_peer.sandesh<\/a> as:<\/p>\n<pre><span style=\"font-family: 'courier new', courier;\"><code> request sandesh BgpNeighborReq {\n 1: string ip_address;\n 2: string domain;\n }\n struct BgpNeighborResp {\n 1: string peer;\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 \/\/ Peer name\n 2: string peer_address (link=\"BgpNeighborReq\");\n 3: u32 peer_asn;\n response sandesh BgpNeighborListResp {\n 1: list&lt;BgpNeighborResp&gt; neighbors;\n }<\/code><\/span><\/pre>\n<p style=\"text-align: justify;\">To debug, developer can access the web page at http:\/\/&lt;IP-Address of control-node&gt;:8083\/Snh_BgpNeighborReq?ip_address=&amp;domain= using curl or the web browser and get the XML data corresponding to the response sandesh from the control-node.<\/p>\n<p style=\"text-align: justify;\">The developers specify the commands supported by the web server (GETs) by defining a request sandesh. The data is returned in a response sandesh. The collector can also send a request sandesh and the response sandesh sent to the collector will be stored in the analytics database. Request and response sandesh thus provide a RESTful API to debugging the software modules.<\/p>\n<h6 style=\"text-align: justify;\">Wrapping Up<\/h6>\n<p style=\"text-align: justify;\">Monitoring and running a multi-tenant data-center requires strong SDN analytics. Exposing the right network abstractions and having appropriate aggregation and syncing mechanisms are crucial for analytics to scale in massively distributed systems. The importance of open APIs cannot be understated in achieving the goal of SDN analytics to enable humans to cost-effectively monitor and operate a multi-tenant, multi-vendor data center.<\/p>\n<p style=\"text-align: justify;\">Most modern network operating systems support C++, and Python, and by using Sandesh as the southbound interface, OpenContrail Analytics solution can be used to provide a consolidated view and deep insight across virtual and physical networks and events even in a multi-vendor environment.\u00a0 As the blog post illustrates, Sandesh is an open southbound interface and protocol that enables developers to expose the right abstractions and aggregation mechanisms required for SDN analytics. Integrating Sandesh on existing physical routers and switches in a multi-vendor environment is just a matter of defining the right abstractions and aggregation mechanisms in the IDL and using the back-end library. In future blog entries we will discuss the OpenContrail Analytics Engine aggregation and syncing mechanisms as well as the statistics collection mechanisms in detail.<\/p>\n","protected":false},"excerpt":{"rendered":"<p>In a previous blog posting titled \u201cDebugging and System Visibility in a SDN Environment\u201d, OpenContrail Software Engineer and my colleague, Anish Mehta, gave an overview of the challenges and opportunities&#8230;<\/p>\n","protected":false},"author":470,"featured_media":0,"comment_status":"open","ping_status":"closed","sticky":false,"template":"","format":"standard","meta":{"footnotes":""},"categories":[4,1],"tags":[],"acf":[],"yoast_head":"<!-- This site is optimized with the Yoast SEO plugin v21.6 - https:\/\/yoast.com\/wordpress\/plugins\/seo\/ -->\n<title>Sandesh \u2013 A SDN Analytics Interface - Tungsten Fabric<\/title>\n<meta name=\"robots\" content=\"index, follow, max-snippet:-1, max-image-preview:large, max-video-preview:-1\" \/>\n<link rel=\"canonical\" href=\"https:\/\/tungsten.io\/sandesh-a-sdn-analytics-interface\/\" \/>\n<meta property=\"og:locale\" content=\"en_US\" \/>\n<meta property=\"og:type\" content=\"article\" \/>\n<meta property=\"og:title\" content=\"Sandesh \u2013 A SDN Analytics Interface - Tungsten Fabric\" \/>\n<meta property=\"og:description\" content=\"In a previous blog posting titled \u201cDebugging and System Visibility in a SDN Environment\u201d, OpenContrail Software Engineer and my colleague, Anish Mehta, gave an overview of the challenges and opportunities...\" \/>\n<meta property=\"og:url\" content=\"https:\/\/tungsten.io\/sandesh-a-sdn-analytics-interface\/\" \/>\n<meta property=\"og:site_name\" content=\"Tungsten Fabric\" \/>\n<meta property=\"article:published_time\" content=\"2014-01-23T08:56:25+00:00\" \/>\n<meta property=\"og:image\" content=\"http:\/\/www.opencontrail.org\/wp-content\/uploads\/2014\/01\/sandesh_analytics_blogpost_picture.png\" \/>\n<meta name=\"author\" content=\"Megh Bhatt\" \/>\n<meta name=\"twitter:card\" content=\"summary_large_image\" \/>\n<script type=\"application\/ld+json\" class=\"yoast-schema-graph\">{\"@context\":\"https:\/\/schema.org\",\"@graph\":[{\"@type\":\"WebPage\",\"@id\":\"https:\/\/tungsten.io\/sandesh-a-sdn-analytics-interface\/\",\"url\":\"https:\/\/tungsten.io\/sandesh-a-sdn-analytics-interface\/\",\"name\":\"Sandesh \u2013 A SDN Analytics Interface - Tungsten Fabric\",\"isPartOf\":{\"@id\":\"https:\/\/tungsten.io\/#website\"},\"datePublished\":\"2014-01-23T08:56:25+00:00\",\"dateModified\":\"2014-01-23T08:56:25+00:00\",\"author\":{\"@id\":\"https:\/\/tungsten.io\/#\/schema\/person\/1d0478d6645b11771e102f52bdd1c3b0\"},\"inLanguage\":\"en-US\",\"potentialAction\":[{\"@type\":\"ReadAction\",\"target\":[\"https:\/\/tungsten.io\/sandesh-a-sdn-analytics-interface\/\"]}]},{\"@type\":\"WebSite\",\"@id\":\"https:\/\/tungsten.io\/#website\",\"url\":\"https:\/\/tungsten.io\/\",\"name\":\"Tungsten Fabric\",\"description\":\"multicloud multistack SDN\",\"potentialAction\":[{\"@type\":\"SearchAction\",\"target\":{\"@type\":\"EntryPoint\",\"urlTemplate\":\"https:\/\/tungsten.io\/?s={search_term_string}\"},\"query-input\":\"required name=search_term_string\"}],\"inLanguage\":\"en-US\"},{\"@type\":\"Person\",\"@id\":\"https:\/\/tungsten.io\/#\/schema\/person\/1d0478d6645b11771e102f52bdd1c3b0\",\"name\":\"Megh Bhatt\",\"image\":{\"@type\":\"ImageObject\",\"inLanguage\":\"en-US\",\"@id\":\"https:\/\/tungsten.io\/#\/schema\/person\/image\/\",\"url\":\"https:\/\/secure.gravatar.com\/avatar\/e5066069ba6eff72142a9250152f8bbc?s=96&d=mm&r=pg\",\"contentUrl\":\"https:\/\/secure.gravatar.com\/avatar\/e5066069ba6eff72142a9250152f8bbc?s=96&d=mm&r=pg\",\"caption\":\"Megh Bhatt\"},\"url\":\"https:\/\/tungsten.io\"}]}<\/script>\n<!-- \/ Yoast SEO plugin. -->","yoast_head_json":{"title":"Sandesh \u2013 A SDN Analytics Interface - Tungsten Fabric","robots":{"index":"index","follow":"follow","max-snippet":"max-snippet:-1","max-image-preview":"max-image-preview:large","max-video-preview":"max-video-preview:-1"},"canonical":"https:\/\/tungsten.io\/sandesh-a-sdn-analytics-interface\/","og_locale":"en_US","og_type":"article","og_title":"Sandesh \u2013 A SDN Analytics Interface - Tungsten Fabric","og_description":"In a previous blog posting titled \u201cDebugging and System Visibility in a SDN Environment\u201d, OpenContrail Software Engineer and my colleague, Anish Mehta, gave an overview of the challenges and opportunities...","og_url":"https:\/\/tungsten.io\/sandesh-a-sdn-analytics-interface\/","og_site_name":"Tungsten Fabric","article_published_time":"2014-01-23T08:56:25+00:00","og_image":[{"url":"http:\/\/www.opencontrail.org\/wp-content\/uploads\/2014\/01\/sandesh_analytics_blogpost_picture.png"}],"author":"Megh Bhatt","twitter_card":"summary_large_image","schema":{"@context":"https:\/\/schema.org","@graph":[{"@type":"WebPage","@id":"https:\/\/tungsten.io\/sandesh-a-sdn-analytics-interface\/","url":"https:\/\/tungsten.io\/sandesh-a-sdn-analytics-interface\/","name":"Sandesh \u2013 A SDN Analytics Interface - Tungsten Fabric","isPartOf":{"@id":"https:\/\/tungsten.io\/#website"},"datePublished":"2014-01-23T08:56:25+00:00","dateModified":"2014-01-23T08:56:25+00:00","author":{"@id":"https:\/\/tungsten.io\/#\/schema\/person\/1d0478d6645b11771e102f52bdd1c3b0"},"inLanguage":"en-US","potentialAction":[{"@type":"ReadAction","target":["https:\/\/tungsten.io\/sandesh-a-sdn-analytics-interface\/"]}]},{"@type":"WebSite","@id":"https:\/\/tungsten.io\/#website","url":"https:\/\/tungsten.io\/","name":"Tungsten Fabric","description":"multicloud multistack SDN","potentialAction":[{"@type":"SearchAction","target":{"@type":"EntryPoint","urlTemplate":"https:\/\/tungsten.io\/?s={search_term_string}"},"query-input":"required name=search_term_string"}],"inLanguage":"en-US"},{"@type":"Person","@id":"https:\/\/tungsten.io\/#\/schema\/person\/1d0478d6645b11771e102f52bdd1c3b0","name":"Megh Bhatt","image":{"@type":"ImageObject","inLanguage":"en-US","@id":"https:\/\/tungsten.io\/#\/schema\/person\/image\/","url":"https:\/\/secure.gravatar.com\/avatar\/e5066069ba6eff72142a9250152f8bbc?s=96&d=mm&r=pg","contentUrl":"https:\/\/secure.gravatar.com\/avatar\/e5066069ba6eff72142a9250152f8bbc?s=96&d=mm&r=pg","caption":"Megh Bhatt"},"url":"https:\/\/tungsten.io"}]}},"_links":{"self":[{"href":"https:\/\/tungsten.io\/wp-json\/wp\/v2\/posts\/1213"}],"collection":[{"href":"https:\/\/tungsten.io\/wp-json\/wp\/v2\/posts"}],"about":[{"href":"https:\/\/tungsten.io\/wp-json\/wp\/v2\/types\/post"}],"author":[{"embeddable":true,"href":"https:\/\/tungsten.io\/wp-json\/wp\/v2\/users\/470"}],"replies":[{"embeddable":true,"href":"https:\/\/tungsten.io\/wp-json\/wp\/v2\/comments?post=1213"}],"version-history":[{"count":0,"href":"https:\/\/tungsten.io\/wp-json\/wp\/v2\/posts\/1213\/revisions"}],"wp:attachment":[{"href":"https:\/\/tungsten.io\/wp-json\/wp\/v2\/media?parent=1213"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"https:\/\/tungsten.io\/wp-json\/wp\/v2\/categories?post=1213"},{"taxonomy":"post_tag","embeddable":true,"href":"https:\/\/tungsten.io\/wp-json\/wp\/v2\/tags?post=1213"}],"curies":[{"name":"wp","href":"https:\/\/api.w.org\/{rel}","templated":true}]}}