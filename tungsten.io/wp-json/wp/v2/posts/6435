{"id":6435,"date":"2015-07-29T13:40:58","date_gmt":"2015-07-29T20:40:58","guid":{"rendered":"http:\/\/www.opencontrail.org\/?p=6435"},"modified":"2015-07-29T13:40:58","modified_gmt":"2015-07-29T20:40:58","slug":"a-journey-of-a-packet-within-opencontrail","status":"publish","type":"post","link":"https:\/\/tungsten.io\/a-journey-of-a-packet-within-opencontrail\/","title":{"rendered":"A journey of a packet within OpenContrail"},"content":{"rendered":"<p><em>This is a guest blog by <span class=\"author vcard\"><a class=\"url fn n\" title=\"Sylvain Afchain\" href=\"https:\/\/twitter.com\/s_afchain\" target=\"_blank\" rel=\"author\">Sylvain Afchain <\/a><\/span> from RedHat. <a href=\"http:\/\/techs.enovance.com\/7640\/a-journey-of-a-packet-within-opencontrail\" target=\"_blank\">Click here<\/a> for the original post.<\/em><\/p>\n<p>In this post we will see how a packet generated by a VM is able to reach another VM or an external resource, what are the key concepts\/components in the context of Neutron using the OpenContrail plugin. We will focus on OpenContrail, how it implements the overlay and the tools that it provides to check\/troubleshoot how the packet are forwarded. Before getting started, I\u2019ll give a little overview of the key concepts of OpenContrail.<\/p>\n<h4>Virtual networks, Overlay with OpenContrail<\/h4>\n<p>For the overlay, OpenContrail uses MPLS L3VPNs and MPLS EVPNs in order to address both l3 overlay and l2 overlay. There are a lot of components within OpenContrail, however we will focus on two key components \u2013 controller and the vRouter.<\/p>\n<p>For the control plane each controller acts as a BGP Route Reflector using the BGP and the XMPP protocols. BGP is used between the controllers and the physical routers. XMPP is used between the controllers and the vRouters. The XMPP protocol transports BGP route announcements but also some other informations for non routing needs.<\/p>\n<p>For the data plane, OpenContrail supports GRE\/VXLAN\/UDP for the tunneling. OpenContrail requires the following features to be supported by the gateway router :<\/p>\n<ul>\n<li>L3VPN\n<ul>\n<li><a href=\"http:\/\/tools.ietf.org\/html\/rfc4364\">http:\/\/tools.ietf.org\/html\/rfc4364<\/a><\/li>\n<\/ul>\n<\/li>\n<li>MP-BGP\n<ul>\n<li><a href=\"http:\/\/tools.ietf.org\/html\/rfc4760\">http:\/\/tools.ietf.org\/html\/rfc4760<\/a><\/li>\n<\/ul>\n<\/li>\n<li>Dynamic Tunneling<\/li>\n<\/ul>\n<p><a href=\"http:\/\/www.opencontrail.org\/wp-content\/uploads\/2015\/07\/safchain_blogpost_728_image1.png\"><img loading=\"lazy\" decoding=\"async\" class=\"aligncenter wp-image-6436\" src=\"http:\/\/www.opencontrail.org\/wp-content\/uploads\/2015\/07\/safchain_blogpost_728_image1.png\" alt=\"safchain_blogpost_728_image1\" width=\"533\" height=\"300\" data-id=\"6436\" \/><\/a><\/p>\n<p>In this post we will focus on the data plane area.<\/p>\n<h2 id=\"3\">The packet\u2019s journey<\/h2>\n<p>In order to show what is the journey of a packet, let\u2019s play with the following topology, where we have two VMs on two different networks connected thanks to a router.<\/p>\n<p><img loading=\"lazy\" decoding=\"async\" class=\"aligncenter size-full wp-image-6437\" src=\"http:\/\/www.opencontrail.org\/wp-content\/uploads\/2015\/07\/safchain_blogpost_728_image2.png\" alt=\"safchain_blogpost_728_image2\" width=\"564\" height=\"552\" data-id=\"6437\" \/><\/p>\n<p>Assuming we have allowed the ICMP packets by setting the security groups accordingly we can start a ping from <i>vm1<\/i> toward <i>vm2<\/i>.<\/p>\n<p>There are a lot of introspection tools within OpenContrail which can be used to get a clear status on how the packets are forwarded.<\/p>\n<p>Initiating a ping between <i>vm1<\/i> and <i>vm2<\/i>, we can check step by step where the packets go.<\/p>\n<p>Since the VMs are not on the same network, they will both use their default gateway. The local vRouter answers to the ARP request of the default gateway IP with its own MAC.<\/p>\n<pre><span style=\"font-family: 'courier new', courier;\">\nvm1$ ip route\ndefault via 10.0.0.1 dev eth0\n10.0.0.0\/24 dev eth0  src 10.0.0.3\n \n$ cat \/proc\/net\/arp\nIP address       HW type     Flags       HW address            Mask     Device\n10.0.0.1         0x1         0x2         00:00:5e:00:01:00     *        eth0<\/span><\/pre>\n<p>Now that we have seen that the packets will be forwarded to the local vRouter, we are going to check how the vRouter will forward them.<\/p>\n<p>So let\u2019s start by checking at the data plane layer by browsing the vRouter agent introspect Web interface running on the compute nodes hosting our VMs at <i>http:\/\/&lt;vrouter agent ip&gt;:8085\/agent.xml<\/i><\/p>\n<p>There is a plenty of sub-interfaces, but we will only use three of them:<\/p>\n<ul>\n<li>VrfListReq, http:\/\/&lt;vrouter agent ip&gt;:8085\/Snh_VrfListReqWhich gives you the networks and the VRFs related. For a given VRF \u2013 let\u2019s say the Unicast VRF (ucindex) \u2013 we can see all the routes.<\/li>\n<\/ul>\n<ul>\n<li>ItfReq, http:\/\/&lt;vrouter agent ip&gt;:8085\/Snh_ItfReqWhich gives you all the interfaces handled by the vRouter.<\/li>\n<li>MplsReq, http:\/\/&lt;vrouter agent ip&gt;:8085\/Snh_MplsReqWhich gives all the association MPLS Label\/NextHop for the given vRouter<\/li>\n<\/ul>\n<p>These interfaces are just XML document rendered thanks to a XSL stylesheet, so can be easily processed by some monitoring scripts for example.<\/p>\n<p>We can start by the interfaces (ItfReq) introspect page to find the TAP interface corresponding to VM1. The name of the TAP contains a part of the neutron port ID.<\/p>\n<p><img loading=\"lazy\" decoding=\"async\" class=\"aligncenter wp-image-6445\" src=\"http:\/\/www.opencontrail.org\/wp-content\/uploads\/2015\/07\/safchain_blogpost_728_image6.png\" alt=\"safchain_blogpost_728_image6\" width=\"739\" height=\"300\" data-id=\"6445\" \/><\/p>\n<p>Beside the interface we see the VRF name associated to the network that the interface belong to. On the same line we have some others informations, security group, floating-ips, VM id, etc.<\/p>\n<p>Clicking on the VRF link brings us to the index page of this VRF. We see that we have links to VRFs according to their type: Unicast, Multicast, Layer 2. By default, OpenContrail doesn\u2019t handle the Layer 2. As said before most of the Layer 2 traffic from the virtual machines are trapped by the local vRouter which acts as an ARP responder. But some specific packets like broadcasts still need to be handled, that\u2019s why there is a specific Layer 2 VRF.<\/p>\n<p><img loading=\"lazy\" decoding=\"async\" class=\"aligncenter wp-image-6442 size-full\" src=\"http:\/\/www.opencontrail.org\/wp-content\/uploads\/2015\/07\/safchain_blogpost_728_image3.png\" alt=\"safchain_blogpost_728_image3\" width=\"688\" height=\"241\" data-id=\"6442\" \/><\/p>\n<p>Clicking on the link in the <i>ucindex<\/i> (Unicast) column, we can see all the unicast L3 routes of our virtual network handled by this vRouter. Since <i>vm1<\/i> should be able to reach vm2, we should see a route with the IP of <i>vm2<\/i>.<\/p>\n<p><img loading=\"lazy\" decoding=\"async\" class=\"aligncenter wp-image-6443\" src=\"http:\/\/www.opencontrail.org\/wp-content\/uploads\/2015\/07\/safchain_blogpost_728_image4.png\" alt=\"safchain_blogpost_728_image4\" width=\"842\" height=\"400\" data-id=\"6443\" \/><\/p>\n<p>Thanks to this interface we see that in order to reach the IP 192.168.0.3 which is the IP of our <i>vm2<\/i>, the packet is going to be forwarded through a GRE tunnel whose endpoint is the IP of the compute node hosting <i>vm2<\/i>. That\u2019s what we see in the \u201c<i>dip<\/i>\u201d (Destination IP) field. We see that the packet will be encapsulated in a MPLS packet. The MPLS label will be 16, as shown in the label column.<\/p>\n<p>Ok, so we saw at the agent level how the packet is going to be forwarded, but we may want to check on the datapath side. OpenContrail provides command line tools for that purpose.<\/p>\n<p>In the case of the agent for instance, we can see the interfaces handled by the vRouter kernel module and the associated VRF.<\/p>\n<pre><span style=\"font-family: 'courier new', courier;\">$ vif --list\nVrouter Interface Table\n \nFlags: P=Policy, X=Cross Connect, S=Service Chain, Mr=Receive Mirror\n      Mt=Transmit Mirror, Tc=Transmit Checksum Offload, L3=Layer 3, L2=Layer 2\n      D=DHCP, Vp=Vhost Physical, Pr=Promiscuous, Vnt=Native Vlan Tagged\n      Mnp=No MAC Proxy, Dpdk=DPDK PMD Interface, Rfl=Receive Filtering Offload, \n      Mon=Interface is Monitored, Uuf=Unknown Unicast Flood\n \nvif0\/0      OS: eth0\n           Type:Physical HWaddr:fa:16:3e:68:f9:e8 IPaddr:0\n           Vrf:0 Flags:TcL3L2Vp MTU:1514 Ref:5\n           RX packets:1598309  bytes:315532297 errors:0\n           TX packets:1407307  bytes:383580260 errors:0\n \nvif0\/1      OS: vhost0\n           Type:Host HWaddr:fa:16:3e:68:f9:e8 IPaddr:a2b5b0a\n           Vrf:0 Flags:L3L2 MTU:1514 Ref:3\n           RX packets:1403461  bytes:383378275 errors:0\n           TX packets:1595855  bytes:315456061 errors:0\n \nvif0\/2      OS: pkt0\n           Type:Agent HWaddr:00:00:5e:00:01:00 IPaddr:0\n           Vrf:65535 Flags:L3 MTU:1514 Ref:2\n           RX packets:4389  bytes:400688 errors:0\n           TX packets:6931  bytes:548756 errors:0\n \nvif0\/3      OS: tapa87ad91e-28\n           Type:Virtual HWaddr:00:00:5e:00:01:00 IPaddr:0\n           Vrf:1 Flags:PL3L2 MTU:9160 Ref:6\n           RX packets:565  bytes:105481 errors:0\n           TX packets:587  bytes:80083 errors:0\n \nvif0\/4350   OS: pkt3\n           Type:Stats HWaddr:00:00:00:00:00:00 IPaddr:0\n           Vrf:65535 Flags:L3L2 MTU:9136 Ref:1\n           RX packets:3  bytes:294 errors:0\n           TX packets:3  bytes:252 errors:0\n \nvif0\/4351   OS: pkt1\n           Type:Stats HWaddr:00:00:00:00:00:00 IPaddr:0\n           Vrf:65535 Flags:L3L2 MTU:9136 Ref:1\n           RX packets:10  bytes:840 errors:0\n           TX packets:10  bytes:840 errors:0<\/span><\/pre>\n<p>We have our TAP interface at this index 3 and the VRF associated which is the number 1.<\/p>\n<p>Let\u2019s now check the routes for this VRF. For that purpose we use the rt command line.<\/p>\n<pre><span style=\"font-family: 'courier new', courier;\">$ rt --dump 1\nVrouter inet4 routing table 0\/1\/unicast\nFlags: L=Label Valid, P=Proxy ARP, T=Trap ARP, F=Flood ARP\n \nDestination          PPL        Flags        Label         Nexthop    Stitched MAC(Index)\n \n...\n192.168.0.3\/32         32           LP         16             19        -\n...<\/span><\/pre>\n<p>We see that the MPLS label used is 16. In order to know how the packet will be forwarded we have to check the NextHop used for this route.<\/p>\n<pre><span style=\"font-family: 'courier new', courier;\">$ nh --get 19\nId:19         Type:Tunnel    Fmly: AF_INET  Flags:Valid, MPLSoGRE,   Rid:0  Ref_cnt:2 Vrf:0\n             Oif:0 Len:14 Flags Valid, MPLSoGRE,  Data:fa 16 3e 4b f6 05 fa 16 3e 68 f9 e8 08 00\n             Vrf:0  Sip:10.43.91.10  Dip:10.43.91.12<\/span><\/pre>\n<p>We have almost the same informations that the agent gave us. Here in the Oif field, we have the interface where the packet will be sent to the other compute node. Thanks to the vif command line we can get the details about this interface.<\/p>\n<pre><span style=\"font-family: 'courier new', courier;\">$ vif --get 0\nVrouter Interface Table\n \nFlags: P=Policy, X=Cross Connect, S=Service Chain, Mr=Receive Mirror\n      Mt=Transmit Mirror, Tc=Transmit Checksum Offload, L3=Layer 3, L2=Layer 2\n      D=DHCP, Vp=Vhost Physical, Pr=Promiscuous, Vnt=Native Vlan Tagged\n      Mnp=No MAC Proxy, Dpdk=DPDK PMD Interface, Rfl=Receive Filtering Offload, Mon=Interface is Monitored\n      Uuf=Unknown Unicast Flood\n \nvif0\/0      OS: eth0\n           Type:Physical HWaddr:fa:16:3e:68:f9:e8 IPaddr:0\n           Vrf:0 Flags:TcL3L2Vp MTU:1514 Ref:5\n           RX packets:1602164  bytes:316196179 errors:0\n           TX packets:1410642  bytes:384855228 errors:0<\/span><\/pre>\n<p>As the packet will go through the eth0 interface, a tcpdump should confirm what we described above.<\/p>\n<pre><span style=\"font-family: 'courier new', courier;\">$ sudo tcpdump -n -i eth0 dst 10.43.91.12\n12:13:16.908957 IP 10.43.91.10 &gt; 10.43.91.12: GREv0, \nlength 92: MPLS (label 16, exp 0, [S], ttl 63) \nIP 10.0.0.3 &gt; 192.168.0.3: ICMP echo request, id 5889, seq 43, length 64<\/span><\/pre>\n<p>As the tunnel endpoint shows, the packet will be directly forwarded to the compute node that is hosting the destination VM, not using a third party routing device.<\/p>\n<p>On the other side, the vRouter on the second compute node will receive the encapsulated packet. According to the MPLS Label, it does a lookup on a MPLS Label\/NextHop as we can see on its introspect.<\/p>\n<p>&nbsp;<\/p>\n<p>&nbsp;<\/p>\n<p><img loading=\"lazy\" decoding=\"async\" class=\"aligncenter size-full wp-image-6444\" src=\"http:\/\/www.opencontrail.org\/wp-content\/uploads\/2015\/07\/safchain_blogpost_728_image5.png\" alt=\"safchain_blogpost_728_image5\" width=\"678\" height=\"538\" data-id=\"6444\" \/><\/p>\n<p>As we can see here the NextHop field for the Label 16 is the TAP interface of our second VM. On the datapath side we can check the same informations. Checking the MPLS Label\/NextHop table :<\/p>\n<pre><span style=\"font-family: 'courier new', courier;\">$ mpls --get 16\nMPLS Input Label Map\n \n  Label    NextHop\n-------------------\n     16        14<\/span><\/pre>\n<p>..and finally the NextHop and the interface with the following commands :<\/p>\n<pre><span style=\"font-family: 'courier new', courier;\">$ nh --get 14\nId:14         Type:Encap     Fmly: AF_INET  Flags:Valid, Policy,   Rid:0  Ref_cnt:4 Vrf:1\n             EncapFmly:0806 Oif:3 Len:14 Data:02 8a 39 ff 98 d3 00 00 5e 00 01 00 08 00\n\n$ vif --get 3\nVrouter Interface Table\n \nFlags: P=Policy, X=Cross Connect, S=Service Chain, Mr=Receive Mirror\n      Mt=Transmit Mirror, Tc=Transmit Checksum Offload, L3=Layer 3, L2=Layer 2\n      D=DHCP, Vp=Vhost Physical, Pr=Promiscuous, Vnt=Native Vlan Tagged\n      Mnp=No MAC Proxy, Dpdk=DPDK PMD Interface, Rfl=Receive Filtering Offload, Mon=Interface is Monitored\n      Uuf=Unknown Unicast Flood\n \nvif0\/3      OS: tap8a39ff98-d3\n           Type:Virtual HWaddr:00:00:5e:00:01:00 IPaddr:0\n           Vrf:1 Flags:PL3L2 MTU:9160 Ref:6\n           RX packets:2957  bytes:293636 errors:0\n           TX packets:3085  bytes:297115 errors:0<\/span><\/pre>\n<p>This post was just an overview on how the packets are forwarded from one node to another and what are the interfaces\/tools that you can use for troubleshooting purpose. One of the interesting thing with OpenContrail is that almost all the components have their own introspect interface helping you a lot during troubleshooting sessions. As we saw, the routing is fully distributed in OpenContrail, each vRouter handles a part of the routing using well known routing protocols like BGP\/MPLS which proved their ability to scale.<\/p>\n","protected":false},"excerpt":{"rendered":"<p>This is a guest blog by Sylvain Afchain from RedHat. Click here for the original post. In this post we will see how a packet generated by a VM is&#8230;<\/p>\n","protected":false},"author":485,"featured_media":0,"comment_status":"open","ping_status":"closed","sticky":false,"template":"","format":"standard","meta":{"footnotes":""},"categories":[5,15,6,7,8,1],"tags":[],"acf":[],"yoast_head":"<!-- This site is optimized with the Yoast SEO plugin v21.6 - https:\/\/yoast.com\/wordpress\/plugins\/seo\/ -->\n<title>A journey of a packet within OpenContrail - Tungsten Fabric<\/title>\n<meta name=\"robots\" content=\"index, follow, max-snippet:-1, max-image-preview:large, max-video-preview:-1\" \/>\n<link rel=\"canonical\" href=\"https:\/\/tungsten.io\/a-journey-of-a-packet-within-opencontrail\/\" \/>\n<meta property=\"og:locale\" content=\"en_US\" \/>\n<meta property=\"og:type\" content=\"article\" \/>\n<meta property=\"og:title\" content=\"A journey of a packet within OpenContrail - Tungsten Fabric\" \/>\n<meta property=\"og:description\" content=\"This is a guest blog by Sylvain Afchain from RedHat. Click here for the original post. In this post we will see how a packet generated by a VM is...\" \/>\n<meta property=\"og:url\" content=\"https:\/\/tungsten.io\/a-journey-of-a-packet-within-opencontrail\/\" \/>\n<meta property=\"og:site_name\" content=\"Tungsten Fabric\" \/>\n<meta property=\"article:published_time\" content=\"2015-07-29T20:40:58+00:00\" \/>\n<meta property=\"og:image\" content=\"http:\/\/www.opencontrail.org\/wp-content\/uploads\/2015\/07\/safchain_blogpost_728_image1.png\" \/>\n<meta name=\"author\" content=\"Sylvain Afchain\" \/>\n<meta name=\"twitter:card\" content=\"summary_large_image\" \/>\n<script type=\"application\/ld+json\" class=\"yoast-schema-graph\">{\"@context\":\"https:\/\/schema.org\",\"@graph\":[{\"@type\":\"WebPage\",\"@id\":\"https:\/\/tungsten.io\/a-journey-of-a-packet-within-opencontrail\/\",\"url\":\"https:\/\/tungsten.io\/a-journey-of-a-packet-within-opencontrail\/\",\"name\":\"A journey of a packet within OpenContrail - Tungsten Fabric\",\"isPartOf\":{\"@id\":\"https:\/\/tungsten.io\/#website\"},\"datePublished\":\"2015-07-29T20:40:58+00:00\",\"dateModified\":\"2015-07-29T20:40:58+00:00\",\"author\":{\"@id\":\"https:\/\/tungsten.io\/#\/schema\/person\/48d9e43ea44dac7ba18d184f67132533\"},\"inLanguage\":\"en-US\",\"potentialAction\":[{\"@type\":\"ReadAction\",\"target\":[\"https:\/\/tungsten.io\/a-journey-of-a-packet-within-opencontrail\/\"]}]},{\"@type\":\"WebSite\",\"@id\":\"https:\/\/tungsten.io\/#website\",\"url\":\"https:\/\/tungsten.io\/\",\"name\":\"Tungsten Fabric\",\"description\":\"multicloud multistack SDN\",\"potentialAction\":[{\"@type\":\"SearchAction\",\"target\":{\"@type\":\"EntryPoint\",\"urlTemplate\":\"https:\/\/tungsten.io\/?s={search_term_string}\"},\"query-input\":\"required name=search_term_string\"}],\"inLanguage\":\"en-US\"},{\"@type\":\"Person\",\"@id\":\"https:\/\/tungsten.io\/#\/schema\/person\/48d9e43ea44dac7ba18d184f67132533\",\"name\":\"Sylvain Afchain\",\"image\":{\"@type\":\"ImageObject\",\"inLanguage\":\"en-US\",\"@id\":\"https:\/\/tungsten.io\/#\/schema\/person\/image\/\",\"url\":\"https:\/\/secure.gravatar.com\/avatar\/5e822d4b7f2bb63390d27fc798fc7261?s=96&d=mm&r=pg\",\"contentUrl\":\"https:\/\/secure.gravatar.com\/avatar\/5e822d4b7f2bb63390d27fc798fc7261?s=96&d=mm&r=pg\",\"caption\":\"Sylvain Afchain\"},\"url\":\"https:\/\/tungsten.io\"}]}<\/script>\n<!-- \/ Yoast SEO plugin. -->","yoast_head_json":{"title":"A journey of a packet within OpenContrail - Tungsten Fabric","robots":{"index":"index","follow":"follow","max-snippet":"max-snippet:-1","max-image-preview":"max-image-preview:large","max-video-preview":"max-video-preview:-1"},"canonical":"https:\/\/tungsten.io\/a-journey-of-a-packet-within-opencontrail\/","og_locale":"en_US","og_type":"article","og_title":"A journey of a packet within OpenContrail - Tungsten Fabric","og_description":"This is a guest blog by Sylvain Afchain from RedHat. Click here for the original post. In this post we will see how a packet generated by a VM is...","og_url":"https:\/\/tungsten.io\/a-journey-of-a-packet-within-opencontrail\/","og_site_name":"Tungsten Fabric","article_published_time":"2015-07-29T20:40:58+00:00","og_image":[{"url":"http:\/\/www.opencontrail.org\/wp-content\/uploads\/2015\/07\/safchain_blogpost_728_image1.png"}],"author":"Sylvain Afchain","twitter_card":"summary_large_image","schema":{"@context":"https:\/\/schema.org","@graph":[{"@type":"WebPage","@id":"https:\/\/tungsten.io\/a-journey-of-a-packet-within-opencontrail\/","url":"https:\/\/tungsten.io\/a-journey-of-a-packet-within-opencontrail\/","name":"A journey of a packet within OpenContrail - Tungsten Fabric","isPartOf":{"@id":"https:\/\/tungsten.io\/#website"},"datePublished":"2015-07-29T20:40:58+00:00","dateModified":"2015-07-29T20:40:58+00:00","author":{"@id":"https:\/\/tungsten.io\/#\/schema\/person\/48d9e43ea44dac7ba18d184f67132533"},"inLanguage":"en-US","potentialAction":[{"@type":"ReadAction","target":["https:\/\/tungsten.io\/a-journey-of-a-packet-within-opencontrail\/"]}]},{"@type":"WebSite","@id":"https:\/\/tungsten.io\/#website","url":"https:\/\/tungsten.io\/","name":"Tungsten Fabric","description":"multicloud multistack SDN","potentialAction":[{"@type":"SearchAction","target":{"@type":"EntryPoint","urlTemplate":"https:\/\/tungsten.io\/?s={search_term_string}"},"query-input":"required name=search_term_string"}],"inLanguage":"en-US"},{"@type":"Person","@id":"https:\/\/tungsten.io\/#\/schema\/person\/48d9e43ea44dac7ba18d184f67132533","name":"Sylvain Afchain","image":{"@type":"ImageObject","inLanguage":"en-US","@id":"https:\/\/tungsten.io\/#\/schema\/person\/image\/","url":"https:\/\/secure.gravatar.com\/avatar\/5e822d4b7f2bb63390d27fc798fc7261?s=96&d=mm&r=pg","contentUrl":"https:\/\/secure.gravatar.com\/avatar\/5e822d4b7f2bb63390d27fc798fc7261?s=96&d=mm&r=pg","caption":"Sylvain Afchain"},"url":"https:\/\/tungsten.io"}]}},"_links":{"self":[{"href":"https:\/\/tungsten.io\/wp-json\/wp\/v2\/posts\/6435"}],"collection":[{"href":"https:\/\/tungsten.io\/wp-json\/wp\/v2\/posts"}],"about":[{"href":"https:\/\/tungsten.io\/wp-json\/wp\/v2\/types\/post"}],"author":[{"embeddable":true,"href":"https:\/\/tungsten.io\/wp-json\/wp\/v2\/users\/485"}],"replies":[{"embeddable":true,"href":"https:\/\/tungsten.io\/wp-json\/wp\/v2\/comments?post=6435"}],"version-history":[{"count":0,"href":"https:\/\/tungsten.io\/wp-json\/wp\/v2\/posts\/6435\/revisions"}],"wp:attachment":[{"href":"https:\/\/tungsten.io\/wp-json\/wp\/v2\/media?parent=6435"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"https:\/\/tungsten.io\/wp-json\/wp\/v2\/categories?post=6435"},{"taxonomy":"post_tag","embeddable":true,"href":"https:\/\/tungsten.io\/wp-json\/wp\/v2\/tags?post=6435"}],"curies":[{"name":"wp","href":"https:\/\/api.w.org\/{rel}","templated":true}]}}