{"id":1457,"date":"2014-05-02T21:54:36","date_gmt":"2014-05-02T21:54:36","guid":{"rendered":"http:\/\/opencontrail.org\/?p=1457"},"modified":"2014-05-02T21:54:36","modified_gmt":"2014-05-02T21:54:36","slug":"service-chain-load-balancing-with-opencontrail","status":"publish","type":"post","link":"https:\/\/tungsten.io\/service-chain-load-balancing-with-opencontrail\/","title":{"rendered":"Service Chain Load Balancing with OpenContrail"},"content":{"rendered":"<h5>1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 Basic Concepts<\/h5>\n<p>In this paper we discuss the concept of load balancing in a service chain which has multiple virtual machines for scale-out.<\/p>\n<p>Figure 1 introduces the concepts of the length of a service chain and the width of a service chain.<\/p>\n<p><!--more Read more...--><\/p>\n<p>The length of the service chain determines the functionality; if we add more services to the service chain it becomes longer.<\/p>\n<p>The width of the service chain determines the capacity; if we add more capacity to the service chain it becomes wider.<\/p>\n<p>The width of the service chain is not necessarily uniform. In the example below we may have three firewalls (2 Gbps each) but only two caches (3 Gbps each) to implement a 6 Gbps service chain.<\/p>\n<p><img loading=\"lazy\" decoding=\"async\" class=\"alignnone size-full wp-image-5727\" src=\"http:\/\/www.opencontrail.org\/wp-content\/uploads\/2014\/05\/5_2_2014_blogpost_image1.png\" alt=\"5_2_2014_blogpost_image1\" width=\"511\" height=\"299\" data-id=\"5727\" \/><\/p>\n<p>Figure 1: Width and Length of a Service Chain<\/p>\n<p>When there are multiple parallel instances of the same virtual service for scale-out reasons, there must be a load balancing function to spread the traffic across those multiple instances. That load balancing function can be implemented in three locations:<\/p>\n<ol>\n<li>On the physical router on which the service chain is anchored.<\/li>\n<li>In the OpenContrail vRouter in the hypervisor.<\/li>\n<li>In a virtual load balancer which runs in a virtual machine.<\/li>\n<\/ol>\n<h5>2\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 Load Balancing on the Physical Anchor Router<\/h5>\n<p>In many Network Function Virtualization (NFV) use cases, service chains are anchored on (i.e. connected to) a physical router. The anchor router is typically an edge router which sits between the access network to the customer and the core network. The anchor router is responsible for steering the customer traffic flows into the right service chain. This steering function needs to be subscriber aware and application aware. Subscriber awareness means that different subscribers are assigned to different service chains, depending on which services they subscribed to. Application awareness means that different types of applications (e.g. voice versus video steaming) are assigned to different service chains.<\/p>\n<p>Juniper routers such as the MX and the Service Control Gateway (SCG) can be the anchor for a service chain. They provide subscriber-awareness through integration with a policy server such as a RADIUS server or a PCRF server. They provide application-awareness using a built-in Deep Packet Inspection (DPI) function.<\/p>\n<p>If the first service in the service chain is scaled out, the physical anchor router needs to provide a load balancing function as shown in Figure 2 below. In this example the length of the service chain is 1 to keep things simple. We will consider longer service chains in the next section.<\/p>\n<p><img loading=\"lazy\" decoding=\"async\" class=\"alignnone size-full wp-image-5728\" src=\"http:\/\/www.opencontrail.org\/wp-content\/uploads\/2014\/05\/5_2_2014_blogpost_image2.png\" alt=\"5_2_2014_blogpost_image2\" width=\"413\" height=\"319\" data-id=\"5728\" \/><\/p>\n<p>Figure 2: Load Balancing on the Physical Anchor Router<\/p>\n<p>We could use simple Equal Cost Multi Path (ECMP) to spread the traffic over the multiple parallel paths. However, using ECMP causes two problems: symmetry and stickiness. We use the Traffic Load Balancer (TLB) feature on the physical router to minimize (but not eliminate) both of these problems.<\/p>\n<p>&nbsp;<\/p>\n<p><em>Symmetry<\/em><\/p>\n<p>The first problem is symmetry. For every forward flow, the reverse flow must follow the same path. This is required because the services in the service chain are usually stateful and need to see both directions of the flow.<\/p>\n<p>Normal ECMP using the 5-typle hash does not provide symmetry. This is because for a typical hash function <em>hash<\/em>(A,B) \u2260 <em>hash<\/em>(B,A).<\/p>\n<p>Symmetry is typically achieved by using special &#8220;symmetric hash function&#8221; which has the special property that <em>hash<\/em>(A,B) = <em>hash<\/em>(B,A). An example of a simple symmetric hash function is to hash on the source IP only in the forward direction and on the destination IP only in the reverse direction (this hash function has the additional nice benefit of keeping all flows for a given customer together).<\/p>\n<p>Symmetric hashing only works for closed service chains, i.e. for service chains which start and end on the same anchor router as in Figure 2 above. Symmetric hashing does not work for open service chains, i.e. for service chains which start and end on different routers.<\/p>\n<p>To understand why symmetric hashing does not work on open service chains we first need to understand the problem of polarization and the concept of seeds which are illustrated in Figure 3 below. If we use exactly the same hash function at every router, then every flow which goes left at the first router will also go left at the second router. As a result, some paths in the network don&#8217;t receive any traffic. This problem is called polarization. To avoid polarization, each router computes hash function not only over the fields in the header of the packet <em>P<\/em>, but also includes a seed value <em>S<\/em> (sometimes called a salt). The seed value is different at each router, it could be the router ID for example. This removes the polarization from the network: all paths are used.<\/p>\n<p><img loading=\"lazy\" decoding=\"async\" class=\"alignnone size-full wp-image-5729\" src=\"http:\/\/www.opencontrail.org\/wp-content\/uploads\/2014\/05\/5_2_2014_blogpost_image3.png\" alt=\"5_2_2014_blogpost_image3\" width=\"543\" height=\"343\" data-id=\"5729\" \/><\/p>\n<p>Figure 3: The Problem of Polarization and its Solution using Seeds<\/p>\n<p>Now we can understand why symmetric hashing does not work with open service chains. Since the router at the start and at the end of the service chains use different seed values, they will map the same flow onto different paths in the service chain, even if the hash function is symmetric.<\/p>\n<p>We can achieve symmetry for open service chains using a flow table. We describe this mechanism below when we discuss load balancing in the OpenContrail vRouter.<\/p>\n<p><em>Stickiness<\/em><\/p>\n<p>The second problem is flow stickiness.<\/p>\n<p>Once a flow has been assigned to a particular path, we want the flow to remain assigned to that path for the entire duration of the flow. If we move the flow to a different path in the middle of the flow, the flow will typically die. This is because the service on the new path will only start seeing the flow in the middle of the flow and won&#8217;t know what to do with it &#8212; most stateful services need to see the entire flow.<\/p>\n<p>Normal ECMP does not provide flow stickiness.\u00a0\u00a0 This is because ECMP is implemented as a modulo-N division where N is the number of members in the load balancing group. If the number of members in the load balancing group changes from N to N+1 as a result of a scale-out event, all hashes will now be computed modulo N+1 instead of modulo N, and as a result most flows will be moved to a different path.<\/p>\n<p>Let&#8217;s take a concrete example. Let&#8217;s say that there are 5 members in the load balancing group and let&#8217;s say that the hash for flow F is 13. The flow will be assigned to path number (13 modulo 5) = 3. Now, let say that a scale-out event happens while flow F is in progress and the number of load balancing group members increases to 6. Now, flow F will be assigned to path number (13 modulo 6) = 1. Thus, flow F moved from path number 3 to path number 1 and will die.<\/p>\n<p>TLB solves this problem by using consistent hashing. See Wikipedia (<a href=\"http:\/\/en.wikipedia.org\/wiki\/Consistent_hashing\">http:\/\/en.wikipedia.org\/wiki\/Consistent_hashing<\/a>) for the theory on consistent hashing.<\/p>\n<p>The short summary is that consistent hashing <em>minimizes<\/em> the number of flows that are moved when a scale-out or a scale-in event happens. For example, if the number of paths increases from 5 to 6, then the maximum number of flows which are moved is 1\/6 of the flows &#8212; the minimum number needed to re-distribute all the flows equally over 6 members. In contrast, with ECMP approximately 4\/5 of the flows will be moved.<\/p>\n<p>Thus, even with consistent hashing, some flows still get moved, which is why we said that TLB minimizes (but does not completely solve) the problem of stickiness.<\/p>\n<p>Note that flow moves can be completely eliminated with a flow table &#8212; this is what OpenContrail does (see below). Normal routers cannot do this because they do forwarding packet-by-packet without a flow table, but Juniper routers with flow-awareness such as the SCG and the SRX can do it.<\/p>\n<h5>\u00a03\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 Load Balancing in the OpenContrail vRouter<\/h5>\n<p>Figure 4 shows load balancing in the OpenContrail vRouter.<\/p>\n<p><img loading=\"lazy\" decoding=\"async\" class=\"alignnone size-full wp-image-5730\" src=\"http:\/\/www.opencontrail.org\/wp-content\/uploads\/2014\/05\/5_2_2014_blogpost_image4.png\" alt=\"5_2_2014_blogpost_image4\" width=\"572\" height=\"428\" data-id=\"5730\" \/><\/p>\n<p>Figure 4: Load Balancing in the OpenContrail vRouter<\/p>\n<p>We need to do load balancing to spread the traffic from service S<sub>i<\/sub> equally across all instances of service S<sub>i+1<\/sub> in the next step of the service chain.<\/p>\n<p>In Figure 4 above, the firewall service to which the arrow points needs to spread the traffic equally across all three instances of the cache service which is the next service in the service chain.<\/p>\n<p>Load balancing on the vRouter is based on the same mechanism as BGP multi-path. If there are multiple downstream instances of the next service in the service chain, then the vRouter will receive multiple XMPP routes towards the final destination. All the XMPP routes have the same destination prefix, but they have different Route Distinguishers (RDs) to keep them distinct, and they have different next-hops and MPLS labels to identify the different downstream service instances. This is illustrated in Figure 5 below.<\/p>\n<p><img loading=\"lazy\" decoding=\"async\" class=\"alignnone size-full wp-image-5732\" src=\"http:\/\/www.opencontrail.org\/wp-content\/uploads\/2014\/05\/5_2_2014_blogpost_image5.png\" alt=\"5_2_2014_blogpost_image5\" width=\"664\" height=\"345\" data-id=\"5732\" \/><\/p>\n<p>Figure 5: &#8220;BGP Multi-Path&#8221; for Load Balancing on the vRouter<\/p>\n<p>The vRouter needs to solve the same two problems which were described in the previous section, namely symmetry and stickiness. In this case we discuss the stickiness problem first.<\/p>\n<p><em>Stickiness<\/em><\/p>\n<p>The OpenContrail vRouter uses flow tables to solve the flow stickiness problem. The OpenContrail vRouter has a flow table which contains one entry for each active flow.<\/p>\n<p>When the first packet of a flow arrives at the vRouter, there is no entry in the flow table yet. At this point, the vRouter performs an ECMP hash (using the &#8220;BGP multi-path&#8221; mechanism described above) to choose the downstream load balancing group member.<\/p>\n<p>The vRouter then creates an entry in the flow table. The next-hop for the flow table entry contains the chosen downstream load balancing group member. Subsequent packets for the same flow don&#8217;t perform ECMP hashes anymore &#8211; they allow use the already chosen load balancing group member which was stored in the flow table.<\/p>\n<p>As a result, the flow will never move, even when the number of load balancing group members changes as a result of scale-out or scale-in.<\/p>\n<p><em>Symmetry<\/em><\/p>\n<p>When the OpenContrail vRouter receives the first packet for a forward flow, it makes an initial ECMP decision and records that decision in the flow table to achieve stickiness as described above.<\/p>\n<p>At the same time, the OpenContrail vRouter also creates an entry for the reverse flow to achieve symmetry. This is done as follows:<\/p>\n<ol>\n<li>The OpenContrail vRouter does a lookup for the source IP address of the payload (i.e. the inner IP header) in the forwarding table of the routing-instance. This results in set of one or more next-hops. It will be more than one next-hop if there is ECMP. All of these reverse next-hops will be overlay tunnels to the previous service in the service-chain.<\/li>\n<li>The OpenContrail vRouter then observes over which overlay tunnel the traffic was actually received (i.e. the outer IP header).<\/li>\n<li>If the tunnel over which the traffic actually arrived is a member of the ECMP set computed in set 1, then the OpenContrail vRouter also creates a reverse flow entry (in addition to the forward flow entry).<\/li>\n<li>If the traffic starts arriving over a different tunnel, the OpenContrail vRouter updates the reverse flow entry, as long as it continues to meet the criteria of being a member of the reverse ECMP set.<\/li>\n<\/ol>\n<p>This process is conceptually similar to the Reverse Path Forwarding (RPF) check which is performance in multicast forwarding and in unicast RPF (uRPF).<\/p>\n<p><em>&#8220;Bleeding&#8221;<\/em><\/p>\n<p>A feature which has been requested but not yet implemented is the ability to &#8220;bleed&#8221; a service instance before it is taken out of service.<\/p>\n<p>What this means is that the customer wants to be able to remove a service instance from the load balancing group without shutting down the virtual machine just yet.<\/p>\n<p>No new flows must be assigned to the service instance.\u00a0\u00a0 But all existing flows which already go through the service instance must continue to go through the service instance.<\/p>\n<p>Eventually, all the existing flows will go away. When the last flow is gone (or when a time-out occurs) an event must be generated to remove the virtual machine.<\/p>\n<p>This feature is not yet supported. It is easy to achieve in the data plane with the OpenContrail flow tables, but the work-flow has not yet been implemented in the control plane and management plane.<\/p>\n<p><em>&#8220;Real&#8221; load balancer features<\/em><\/p>\n<p>The OpenContrail vRouter is not a general purpose load balancer. &#8220;Real&#8221; load balancers have all sorts of advanced features such as liveness checks, load monitoring, application-aware load balancing etc. The OpenContrail vRouter will, over time, implement some of these features, for example the ability to check the liveness of virtual machines.<\/p>\n<h5>4\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 Orchestration and Dynamic Scale-Out<\/h5>\n<p>When you create a service instance in OpenContrail, you can specify the number of virtual machines for that service instance. In that sense, OpenContrail supports statically scaled-out services.<\/p>\n<p>It is also possible to use the OpenContrail API to dynamically change the number of virtual machines for a service instance. In that sense, OpenContrail provides an API to implement dynamically scaled-out services.<\/p>\n<p>However, monitoring the load of a service and scaling out the service when certain Key Performance Indicators (KPIs) are exceeded is not the job of the OpenContrail vRouter. This function (monitoring, dynamic scale-out, dynamic scale-in, and failure handling) is typically performed by a so-called orchestration system or orchestrator for short.<\/p>\n<p>An orchestration system manages the life cycle of complex applications or complex Virtual Network Functions (VNFs) which consist of multiple virtual machines working together. The typical functions of an orchestrator include:<\/p>\n<ul>\n<li>Some sort of template language to describe the resources in such a complex application: virtual machines, virtual storage, virtual networks, virtual load balancers, virtual databases, etc.<\/li>\n<li>A mechanism to monitor the liveness of a virtual machine and to recover from failures by spinning up a new virtual machine.<\/li>\n<li>A mechanism to monitor the load on a virtual machine and the perform scale-out (or scale-in) when Keep Performance Indicators (KPIs) are exceeded. Often, there is an agent in the virtual machine to allow these KPIs to be application-aware (e.g. HTTP request latency for an Apache web server).<\/li>\n<\/ul>\n<p>All the major public clouds offer orchestration and monitoring as a service. For example Amazon Web Services (AWS) offers <a href=\"https:\/\/aws.amazon.com\/cloudformation\/\">CloudFormation<\/a> and <a href=\"https:\/\/aws.amazon.com\/cloudwatch\/\">CloudWatch<\/a>. OpenStack has <a href=\"https:\/\/wiki.openstack.org\/wiki\/Heat\">Heat<\/a> and <a href=\"https:\/\/wiki.openstack.org\/wiki\/Ceilometer\">Ceilometer<\/a> for orchestrator and monitoring. OpenContrail is being integrated with third-party orchestration systems such as IBM Smart Cloud Orchestrator (SCO), Amdocs Network Function Virtualization Orchestrator (NFVO), and Scarl.<\/p>\n<h5>5\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 Load Balancing in a Virtual Machine<\/h5>\n<p>In section 3 we mentioned that the OpenContrail vRouter has several load balancing features, but cannot be considered a &#8220;real&#8221; load balancer.<\/p>\n<p>There are several companies that offer real virtual load balancers. There are also some open source products such as HAProxy.<\/p>\n<p>It is possible to run a load balancer in a virtual machine and include it in the service chain as shown in Figure 6 below.<\/p>\n<p><img loading=\"lazy\" decoding=\"async\" class=\"alignnone size-full wp-image-5733\" src=\"http:\/\/www.opencontrail.org\/wp-content\/uploads\/2014\/05\/5_2_2014_blogpost_image6.png\" alt=\"5_2_2014_blogpost_image6\" width=\"619\" height=\"301\" data-id=\"5733\" \/><\/p>\n<p>Figure 6: Load Balancing in a Virtual Machine<\/p>\n<p>The advantage of this method is that you can use a best-of-breed &#8220;real&#8221; load balancer.<\/p>\n<p>The disadvantage of this method is that the load balancer itself may become a bottleneck. In that case you have to create multiple instances of the load balancer which introduces a chicken-and-egg problem: how to you spread the traffic over the multiple instances of the load balancer.<\/p>\n<p>In practice, this is not so much a problem as you might think, because these load balancers (e.g. HAProxy) are very light-weight can a single load balancer virtual machine can handle many back-end virtual machines in the load balancing group. Also, for cloud based services Global Load Balancing (GLB) using the Domain Name Service (DNS) is used to spread the traffic across multiple load balancers (this technique does not apply to service chains).<\/p>\n<h5>6\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 Load Balancing in the Underlay<\/h5>\n<p>Everything we have discussed so far relates to load balancing in the overlay. There is a related but separate topic related to load balancing in the underlay.<\/p>\n<p>Figure 7 below shows a scenario where there are multiple equal-cost paths between the anchor point and the first service in the service chain, or between one service instance and the next service instance in the service chain.<\/p>\n<p><img loading=\"lazy\" decoding=\"async\" class=\"alignnone size-full wp-image-5734\" src=\"http:\/\/www.opencontrail.org\/wp-content\/uploads\/2014\/05\/5_2_2014_blogpost_image7.png\" alt=\"5_2_2014_blogpost_image7\" width=\"568\" height=\"255\" data-id=\"5734\" \/><\/p>\n<p>Figure 7: Load Balancing in the Underlay<\/p>\n<p>The underlay uses normal multi-pathing techniques for load balancing. For layer-3 underlays, ECMP is used. For layer-2 underlays, various techniques are used including Multi-Chassis Link Aggregation (MC-LAG), Virtual Chassis (VC). Other techniques include various overlay flavors such as the Locator Identifier Separator Protocol (LISP), Transparent Interconnect of Lots of Links (TRILL), Provider Backbone Bridging (PBB) and proprietary protocols such as Cisco FabricPath.<\/p>\n<p>Overlay networking introduces some complications. The complication is caused by the fact that all packets are encapsulation in an overlay tunnel encapsulation. There are multiple such overlay tunnel encapsulations, including MPLS-over-GRE, MPLS-over-UDP, VX-LAN, NV-GRE, STT, etc. Some of these encapsulations are friendly towards multi-pathing in the underlay and others are not.<\/p>\n<p>One example of an overlay encapsulation which is <em>not <\/em>friendly towards multi-pathing in the underlay is MPLS-over-GRE which is shown in Figure 8 below.<\/p>\n<p><img loading=\"lazy\" decoding=\"async\" class=\"alignnone size-full wp-image-5735\" src=\"http:\/\/www.opencontrail.org\/wp-content\/uploads\/2014\/05\/5_2_2014_blogpost_image8.png\" alt=\"5_2_2014_blogpost_image8\" width=\"582\" height=\"226\" data-id=\"5735\" \/><\/p>\n<p>Figure 8: GRE Overlay Encapsulation: Not Friendly towards Multi-Pathing in the Underlay<\/p>\n<p>The problem with GRE encapsulation is that all the encapsulated packets have the same 5-tuple in the outer header. This means that all traffic for all virtual machines between a given pair of physical servers will be hashed to the same path. This could be avoided by using different GRE keys for each flow (&#8220;putting entropy in the GRE key&#8221;) but not many underlay switches support hashing on the GRE key.<\/p>\n<p>This problem can be avoided by using a UDP-based encapsulation such as MPLS-over-UDP (shown in Figure 9 below) or VXLAN.<\/p>\n<p><img loading=\"lazy\" decoding=\"async\" class=\"alignnone size-full wp-image-5736\" src=\"http:\/\/www.opencontrail.org\/wp-content\/uploads\/2014\/05\/5_2_2014_blogpost_image9.png\" alt=\"5_2_2014_blogpost_image9\" width=\"613\" height=\"225\" data-id=\"5736\" \/><\/p>\n<p>Figure 9: UDP-based Overlay Encapsulation: Friendly towards Multi-Pathing in the Underlay<\/p>\n<p>UDP-based encapsulations are friendlier towards multi-pathing in the underlay because they &#8220;put entropy in the UDP source port&#8221;. The UDP header contains a hash of the header of the encapsulated packet (or frame) in the UDP source port. As a result, different overlay flows will have different UDP source ports in the underlay. Since the underlay typically hashes on the complete 5-tuple, this results in efficient multi-pathing.<\/p>\n<p>A similar mechanism, using MPLS entropy labels, can use used with LSP transport tunnels, but at this stage it is not yet common to run MPLS in the switch fabric underlay: most switch fabrics are Ethernet-based or IP-based, not yet MPLS-based.<\/p>\n<p>OpenContrail uses MPLS-over-UDP by default for all vRouter to vRouter traffic. OpenContrail uses VXLAN by default for all traffic to gateway switches. Both of these encapsulations have good support for multipath in the underlay.<\/p>\n<p>OpenContrail can use MPLS-over-GRE for traffic to gateway routers which only support that encapsulation. This provides interoperability with existing routers.<\/p>\n<p>OpenContrail uses capability negotiation techniques to discover which encapsulations each end-point of a tunnel supports. OpenContrail will automatically pick an encapsulation which is supported by both end-points. If there are multiple choices, OpenContrail will prefer an encapsulation which has good support for multi-pathing. There is no requirement that all tunnels in a given virtual network use the same encapsulation.<\/p>\n","protected":false},"excerpt":{"rendered":"<p>1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 Basic Concepts In this paper we discuss the concept of load balancing in a service chain which has multiple virtual machines for scale-out. Figure 1 introduces the concepts of&#8230;<\/p>\n","protected":false},"author":467,"featured_media":0,"comment_status":"open","ping_status":"closed","sticky":false,"template":"","format":"standard","meta":{"footnotes":""},"categories":[12,1],"tags":[],"acf":[],"yoast_head":"<!-- This site is optimized with the Yoast SEO plugin v21.6 - https:\/\/yoast.com\/wordpress\/plugins\/seo\/ -->\n<title>Service Chain Load Balancing with OpenContrail - Tungsten Fabric<\/title>\n<meta name=\"robots\" content=\"index, follow, max-snippet:-1, max-image-preview:large, max-video-preview:-1\" \/>\n<link rel=\"canonical\" href=\"https:\/\/tungsten.io\/service-chain-load-balancing-with-opencontrail\/\" \/>\n<meta property=\"og:locale\" content=\"en_US\" \/>\n<meta property=\"og:type\" content=\"article\" \/>\n<meta property=\"og:title\" content=\"Service Chain Load Balancing with OpenContrail - Tungsten Fabric\" \/>\n<meta property=\"og:description\" content=\"1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 Basic Concepts In this paper we discuss the concept of load balancing in a service chain which has multiple virtual machines for scale-out. Figure 1 introduces the concepts of...\" \/>\n<meta property=\"og:url\" content=\"https:\/\/tungsten.io\/service-chain-load-balancing-with-opencontrail\/\" \/>\n<meta property=\"og:site_name\" content=\"Tungsten Fabric\" \/>\n<meta property=\"article:published_time\" content=\"2014-05-02T21:54:36+00:00\" \/>\n<meta property=\"og:image\" content=\"http:\/\/www.opencontrail.org\/wp-content\/uploads\/2014\/05\/5_2_2014_blogpost_image1.png\" \/>\n<meta name=\"author\" content=\"Bruno Rijsman\" \/>\n<meta name=\"twitter:card\" content=\"summary_large_image\" \/>\n<script type=\"application\/ld+json\" class=\"yoast-schema-graph\">{\"@context\":\"https:\/\/schema.org\",\"@graph\":[{\"@type\":\"WebPage\",\"@id\":\"https:\/\/tungsten.io\/service-chain-load-balancing-with-opencontrail\/\",\"url\":\"https:\/\/tungsten.io\/service-chain-load-balancing-with-opencontrail\/\",\"name\":\"Service Chain Load Balancing with OpenContrail - Tungsten Fabric\",\"isPartOf\":{\"@id\":\"https:\/\/tungsten.io\/#website\"},\"datePublished\":\"2014-05-02T21:54:36+00:00\",\"dateModified\":\"2014-05-02T21:54:36+00:00\",\"author\":{\"@id\":\"https:\/\/tungsten.io\/#\/schema\/person\/29ba6d45ee3800b7016818b67e9aab2a\"},\"inLanguage\":\"en-US\",\"potentialAction\":[{\"@type\":\"ReadAction\",\"target\":[\"https:\/\/tungsten.io\/service-chain-load-balancing-with-opencontrail\/\"]}]},{\"@type\":\"WebSite\",\"@id\":\"https:\/\/tungsten.io\/#website\",\"url\":\"https:\/\/tungsten.io\/\",\"name\":\"Tungsten Fabric\",\"description\":\"multicloud multistack SDN\",\"potentialAction\":[{\"@type\":\"SearchAction\",\"target\":{\"@type\":\"EntryPoint\",\"urlTemplate\":\"https:\/\/tungsten.io\/?s={search_term_string}\"},\"query-input\":\"required name=search_term_string\"}],\"inLanguage\":\"en-US\"},{\"@type\":\"Person\",\"@id\":\"https:\/\/tungsten.io\/#\/schema\/person\/29ba6d45ee3800b7016818b67e9aab2a\",\"name\":\"Bruno Rijsman\",\"image\":{\"@type\":\"ImageObject\",\"inLanguage\":\"en-US\",\"@id\":\"https:\/\/tungsten.io\/#\/schema\/person\/image\/\",\"url\":\"https:\/\/secure.gravatar.com\/avatar\/c2f3989cc86672722a00756c482788e9?s=96&d=mm&r=pg\",\"contentUrl\":\"https:\/\/secure.gravatar.com\/avatar\/c2f3989cc86672722a00756c482788e9?s=96&d=mm&r=pg\",\"caption\":\"Bruno Rijsman\"},\"url\":\"https:\/\/tungsten.io\"}]}<\/script>\n<!-- \/ Yoast SEO plugin. -->","yoast_head_json":{"title":"Service Chain Load Balancing with OpenContrail - Tungsten Fabric","robots":{"index":"index","follow":"follow","max-snippet":"max-snippet:-1","max-image-preview":"max-image-preview:large","max-video-preview":"max-video-preview:-1"},"canonical":"https:\/\/tungsten.io\/service-chain-load-balancing-with-opencontrail\/","og_locale":"en_US","og_type":"article","og_title":"Service Chain Load Balancing with OpenContrail - Tungsten Fabric","og_description":"1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 Basic Concepts In this paper we discuss the concept of load balancing in a service chain which has multiple virtual machines for scale-out. Figure 1 introduces the concepts of...","og_url":"https:\/\/tungsten.io\/service-chain-load-balancing-with-opencontrail\/","og_site_name":"Tungsten Fabric","article_published_time":"2014-05-02T21:54:36+00:00","og_image":[{"url":"http:\/\/www.opencontrail.org\/wp-content\/uploads\/2014\/05\/5_2_2014_blogpost_image1.png"}],"author":"Bruno Rijsman","twitter_card":"summary_large_image","schema":{"@context":"https:\/\/schema.org","@graph":[{"@type":"WebPage","@id":"https:\/\/tungsten.io\/service-chain-load-balancing-with-opencontrail\/","url":"https:\/\/tungsten.io\/service-chain-load-balancing-with-opencontrail\/","name":"Service Chain Load Balancing with OpenContrail - Tungsten Fabric","isPartOf":{"@id":"https:\/\/tungsten.io\/#website"},"datePublished":"2014-05-02T21:54:36+00:00","dateModified":"2014-05-02T21:54:36+00:00","author":{"@id":"https:\/\/tungsten.io\/#\/schema\/person\/29ba6d45ee3800b7016818b67e9aab2a"},"inLanguage":"en-US","potentialAction":[{"@type":"ReadAction","target":["https:\/\/tungsten.io\/service-chain-load-balancing-with-opencontrail\/"]}]},{"@type":"WebSite","@id":"https:\/\/tungsten.io\/#website","url":"https:\/\/tungsten.io\/","name":"Tungsten Fabric","description":"multicloud multistack SDN","potentialAction":[{"@type":"SearchAction","target":{"@type":"EntryPoint","urlTemplate":"https:\/\/tungsten.io\/?s={search_term_string}"},"query-input":"required name=search_term_string"}],"inLanguage":"en-US"},{"@type":"Person","@id":"https:\/\/tungsten.io\/#\/schema\/person\/29ba6d45ee3800b7016818b67e9aab2a","name":"Bruno Rijsman","image":{"@type":"ImageObject","inLanguage":"en-US","@id":"https:\/\/tungsten.io\/#\/schema\/person\/image\/","url":"https:\/\/secure.gravatar.com\/avatar\/c2f3989cc86672722a00756c482788e9?s=96&d=mm&r=pg","contentUrl":"https:\/\/secure.gravatar.com\/avatar\/c2f3989cc86672722a00756c482788e9?s=96&d=mm&r=pg","caption":"Bruno Rijsman"},"url":"https:\/\/tungsten.io"}]}},"_links":{"self":[{"href":"https:\/\/tungsten.io\/wp-json\/wp\/v2\/posts\/1457"}],"collection":[{"href":"https:\/\/tungsten.io\/wp-json\/wp\/v2\/posts"}],"about":[{"href":"https:\/\/tungsten.io\/wp-json\/wp\/v2\/types\/post"}],"author":[{"embeddable":true,"href":"https:\/\/tungsten.io\/wp-json\/wp\/v2\/users\/467"}],"replies":[{"embeddable":true,"href":"https:\/\/tungsten.io\/wp-json\/wp\/v2\/comments?post=1457"}],"version-history":[{"count":0,"href":"https:\/\/tungsten.io\/wp-json\/wp\/v2\/posts\/1457\/revisions"}],"wp:attachment":[{"href":"https:\/\/tungsten.io\/wp-json\/wp\/v2\/media?parent=1457"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"https:\/\/tungsten.io\/wp-json\/wp\/v2\/categories?post=1457"},{"taxonomy":"post_tag","embeddable":true,"href":"https:\/\/tungsten.io\/wp-json\/wp\/v2\/tags?post=1457"}],"curies":[{"name":"wp","href":"https:\/\/api.w.org\/{rel}","templated":true}]}}