{"id":7279,"date":"2017-01-08T16:03:24","date_gmt":"2017-01-09T00:03:24","guid":{"rendered":"http:\/\/www.opencontrail.org\/?p=7279"},"modified":"2017-01-08T16:03:24","modified_gmt":"2017-01-09T00:03:24","slug":"automating-contrail-cloud-solution","status":"publish","type":"post","link":"https:\/\/tungsten.io\/automating-contrail-cloud-solution\/","title":{"rendered":"Automating Contrail Cloud Solution"},"content":{"rendered":"<h3>Executive summary:<\/h3>\n<p>Contrail Cloud solution is an open cloud network automation product that uses\u00a0software-defined networking (SDN)\u00a0technology to orchestrate the creation of virtual networks with high scalability. It exposes a set of REST APIs for northbound interaction with cloud orchestration tools, as well as other applications. Contrail Cloud solution has multiple components like Contrail controller, Openstack controller and vRouters.<\/p>\n<p>This product creates Virtual Machines on the compute nodes, attach Virtual Machine to the virtual network and connect the Virtual Machine to the storage.<\/p>\n<p>This Document gives details on REST APIs to automate the following,<\/p>\n<ul>\n<li>Verifying hypervisor status<\/li>\n<li>Create Virtual Machine or delete Virtual Machine<\/li>\n<li>Create virtual Networks<\/li>\n<li>Attach Virtual Machine to virtual network<\/li>\n<li>Verifying Virtual Machine status<\/li>\n<li>Get information about existing Virtual Machines<\/li>\n<\/ul>\n<h3>Description:<\/h3>\n<p><a href=\"http:\/\/www.opencontrail.org\/wp-content\/uploads\/2017\/01\/Automating_Contrail_Cloud_Platform_Image1.jpg\"><img loading=\"lazy\" decoding=\"async\" class=\"alignnone size-full wp-image-7280\" src=\"http:\/\/www.opencontrail.org\/wp-content\/uploads\/2017\/01\/Automating_Contrail_Cloud_Platform_Image1.jpg\" alt=\"\" width=\"459\" height=\"433\" data-id=\"7280\" \/><\/a><\/p>\n<p>In contrail cloud solution Openstack server is responsible for creation of Virtual Machines.Openstack<\/p>\n<p>server has inventory of all the Hypervisors.When a VM creation is requested through openstack Horizon GUI or through RESTAPI commands,NOVA component in openstack controller will connect to the Hypervisor (which has sufficient resources to create VM) and request for VM creation.<\/p>\n<p>After VM is created, NEUTRON component in Openstack controller will connect to the Contrail controller and request for attaching the VM to the specefic Virtual Network.Contrail controller will then connect to the vrouter in the\u00a0 Hypervisor (through XMPP protocol) and request for routing instance creation for the specefic virtual network.The same sequence operation repeated for each VM creation.<\/p>\n<p>When the VMs are created on multiple hypervisors.They exchange routes between them.Then MPLS-OVER-GRE\/MPLS-OVER-UDP Tunnels created between them.<\/p>\n<p>RESTAPIs can be used for automating VM creation, VM deletion and other operations described.<\/p>\n<p><a href=\"http:\/\/www.opencontrail.org\/wp-content\/uploads\/2017\/01\/Automating_Contrail_Cloud_Platform_Image2.jpg\"><img loading=\"lazy\" decoding=\"async\" class=\"alignnone size-full wp-image-7281\" src=\"http:\/\/www.opencontrail.org\/wp-content\/uploads\/2017\/01\/Automating_Contrail_Cloud_Platform_Image2.jpg\" alt=\"\" width=\"696\" height=\"492\" data-id=\"7281\" \/><\/a><\/p>\n<p>This picture shows the implementation details of Contrail cloud solution.In this topology PE2 &amp; PE3 will be acting as local Datacenter gateway.PE1 will be the remote Datacenter gateway.<\/p>\n<p>All compute nodes, controllers are attached to IP fabric.The IP Fabric is not aware of the virtual Networks to which the virtual machines are attached.There is no need for the IP fabric to know virtual network details.Between PE2 (&amp;PE3) and compute nodes and between the compute nodes TUNNEL overlays is implemented.So all traffic between compute nodes to PE2\/PE3 or between compute nodes will be encapsulated with TUNNEL header.IP fabric is aware of the IP addresses present in the Tunnel header(as these IP addresses are part of underlay\/IP fabric network.<\/p>\n<p>Contrail controllers will be managing the compute nodes (vRouters) using XMPP.PE2 &amp;PE3 \u00a0will talk to Contrail controllers with BGP.The vRouters in contrail cloud will act similar to PE router in L3 VPN environment.<\/p>\n<p>When a VM in a vRouter need to send traffic to VM in another vRouter in the same datacenter,<\/p>\n<p>the source vRouter will encapsulate the packets with Tunnel header and then forward it to the IP fabric.After the destination vRouter receives the packet it will decapsulate the packets and forward it to the VM.<\/p>\n<p>When vRouter need to send traffic to vRouters in another datacenter it will encapulate packets with Tunnel header and forward it to PE2 or PE3.PE2 or PE3 will decapsulate the MPLS-OVER-UDP header and then encapsulate it with MPLS headers and forward it to PE1.PE1 decapsulate MPLS header and forward the packets to the node in remote Datacenter.<\/p>\n<h3>Automating Contrail\/Openstack Controller:<\/h3>\n<p>This section gives details on Contrail\/Openstack controller Automation.A sample perl code with RESTAPI details given for each operations like virtual network creation,VM creation,VM deletion etc..Perl module LWP::UserAgent and use JSON qw( decode_json encode_json) should be sourced for this.<\/p>\n<h4>Virtual Machine creation:<\/h4>\n<p><strong>OpenStack Token-id and Tenant id:<\/strong><\/p>\n<p>This section gives details on automating VM creation.Before starting VM creation we need to get the token-id and tenant id from the openstack controller.This token id is required to execute any operational commands in the openstack controller.Tenant id is required to find the right openstack project.The sample code given below gives details on this . The Openstack component keystone provides this token-id.<\/p>\n<p>Keystone\u00a0is the identity service used by\u00a0OpenStack\u00a0for authentication (authN) and high-level authorization (authZ). It currently supports token-based authN and user-service authorization.<\/p>\n<p>In this sample code \u201c$OS_tenant_name\u201d is the project name.This name can be found on openstack Horizon GUI(identity-&gt;Projects).Project name is required to find the correct tenant id.The \u201c$CMDpath\u201d shows \u00a0the syntax of RESTAPI command to get token-id from openstack controller.The tenant id and token id collected here will be used in next steps.<\/p>\n<pre><span style=\"font-family: 'courier new', courier;\">my openstack_ip = \u20181.1.1.1\u2019;\n      \t     \tmy  $KEYSTONEport     =  \"5000\";               \n        \t\tmy $OS_tenant_name = \"PROJECTNAME\";\n        \t\tmy $OS_user = \"admin\";\n        \t\tmy $OS_password = \u2018xxxxxx\u2019;\n                 \tmy $CMDpath= \"\/v2.0\/tokens\";\n        \tmy $APIport=$KEYSTONEport;\n        \tmy $url= \"http:\/\/\".$openstack_ip.\":\".$APIport.$CMDpath;\n             my $body =\n        \t{\n               \t\"auth\"   =&gt;\n                      \t   {\n                         \t       \"tenantName\"  =&gt; \"$OS_tenant_name\",\n                               \t \"passwordCredentials\" =&gt;\n                                                {\n                                              \t  \"username\"  =&gt; \"$OS_user\",\n                                              \t  \"password\"  =&gt; \"$OS_password\"\n                                                }\n                          }                     \n         };               \n        \tmy $request  = HTTP::Request-&gt;new( POST =&gt; $url );\n        \tmy $bjson = encode_json $body;\n        \t$request-&gt;content_type(\"application\/json\");\n        \t$request-&gt;authorization_basic( \"$OS_user\", \"$OS_password\" );\n        \t$request-&gt;content($bjson);\n        \tmy $http = LWP::UserAgent-&gt;new-&gt;request($request);\n        \tmy @y = $http-&gt;{_content};\n        \tmy $mes         = JSON::decode_json($y[0]);\n         \n        \tmy $token_id = $mes-&gt;{'access'}{'token'}{'id'};\n        \tmy $token_exp = $mes-&gt;{'access'}{'token'}{'expires'};\n        \tmy $tenant_id = $mes-&gt;{'access'}{'token'}{'tenant'}{'id'};\n        \tprint(\"\\n\\n *******  token_id is $token_id and token_exp is $token_exp and tenant_id is $tenant_id ******* \\n\\n\");<\/span><\/pre>\n<p><strong>Verifying Hypervisor status:<\/strong><\/p>\n<p>Before going to next step we need to verify the status of compute nodes(Hypervisors).Before creating the VM,the Hypervisors should be Up and running.The RESTAPI command &#8220;\/v1.1\/&#8221;.$tenant_id.&#8221;\/os-services&#8221; provides the status of the hypervisors.This is equivalent to \u201cnova service-list command(the output given below).<\/p>\n<pre><span style=\"font-family: 'courier new', courier;\">my $NOVAport         =  \"8774\";\n       $CMDpath= \"\/v1.1\/\".$tenant_id.\"\/os-services\";\n        $APIport=$NOVAport;\n        $url= \"http:\/\/\".$cont_ip.\":\".$APIport.$CMDpath;\n        $request  = HTTP::Request-&gt;new( GET =&gt; $url );\n        $request-&gt;header('content-type' =&gt; 'application\/json');\n        $request-&gt;header('x-auth-token' =&gt; $token_id);\n        $http = LWP::UserAgent-&gt;new-&gt;request($request);\n        @y = $http-&gt;{_content};\n        print Dumper($http);    \n        $mes         = JSON::decode_json($y[0]);\n        my $len = @{$mes-&gt;{\"services\"}};          \n        my %server_to_netaddr_hash;\n        my %test;\n        my $servername;\n        my $state;\n        my $status; \n        my $hostcount=0;\n        for (my $x = 0; $x&lt; $len ; ++$x) { $servername = $mes-&gt;{\"services\"}[$x]{\"host\"};\n                        if( ($servername =~\/vmg\\d+\/) || ($servername =~\/vm\\d+\/) ) {\n\t        $state = $mes-&gt;{\"services\"}[$x]{\"state\"};\n                         my $status = $mes-&gt;{\"services\"}[$x]{\"status\"};\n                         if ($state ne \"up\" || $status ne \"enabled\") {\n        print(\"\\n\\n *******  status or state of host $servername is not correct.The state is $state and status is $status ******* \\n\\n\");\n         return JT::FALSE;\n                        }\n        print (\"\\n\\n *******  status or state of the compute node $servername is correct The state is $state and status is $status ******* \\n\\n\");\n                    $hostcount++;\n\n                   }\n\t}\n\nroot@server01:~# nova service-list\n+----+------------------+--------------+----------+---------+-------+----------------------------+-----------------+\n| Id | Binary           | Host         | Zone     | Status  | State | Updated_at                 | Disabled Reason |\n+----+------------------+--------------+----------+---------+-------+----------------------------+-----------------+\n| 1  | nova-scheduler   | server1 | internal | enabled | up    | 2016-12-09T21:32:39.000000 | -               |\n| 2  | nova-console     |  server1 | internal | enabled | up    | 2016-12-09T21:32:42.000000 | -               |\n| 3  | nova-consoleauth | server1 | internal | enabled | up    | 2016-12-09T21:32:42.000000 | -               |\n| 4  | nova-conductor   | server1 | internal | enabled | up    | 2016-12-09T21:32:38.000000 | -               |\n| 6  | nova-compute     | vm6          | nova     | enabled | up    | 2016-12-09T21:32:38.000000 | -               |\n| 7  | nova-compute     | vm7          | nova     | enabled | up    | 2016-12-09T21:32:35.000000 | -               |\n| 8  | nova-compute     | vm8          | nova     | enabled | up    | 2016-12-09T21:32:38.000000 | -               |\n| 9  | nova-compute     | vm9          | nova     | enabled | up    | 2016-12-09T21:32:33.000000 | -               |\n| 10 | nova-compute     | vm10         | nova     | enabled | up    | 2016-12-09T21:32:41.000000 | -               |\n| 11 | nova-compute     | vm11         | nova     | enabled | up    | 2016-12-09T21:32:41.000000 | -               |\n| 12 | nova-compute     | vm12         | nova     | enabled | up    | 2016-12-09T21:32:33.000000 | -               |\n| 13 | nova-compute     | vm13         | nova     | enabled | up    | 2016-12-09T21:32:37.000000 | -               |\n| 14 | nova-compute     | vm14         | nova     | enabled | up    | 2016-12-09T21:32:41.000000 | -               |\n| 15 | nova-compute     | vm15         | nova     | enabled | up    | 2016-12-09T21:32:39.000000 | -               |\n| 16 | nova-compute     | vm16         | nova     | enabled | up    | 2016-12-09T21:32:42.000000 | -               |\n| 17 | nova-compute     | vm17         | nova     | enabled | up    | 2016-12-09T21:32:33.000000 | -               |\n| 18 | nova-compute     | vm18         | nova     | enabled | up    | 2016-12-09T21:32:40.000000 | -               |\n+----+------------------+--------------+----------+---------+-------+----------------------------+-----------------+\nroot@ server01:~# <\/span><\/pre>\n<p><strong>Creating Virtual Network:<\/strong><\/p>\n<p>The next step is to create virtual Network. Virtual network has to be created before creating VM.<\/p>\n<p>To create virtual Network the following information is required.<\/p>\n<ul>\n<li>Network segment address and netmask<\/li>\n<li>Gateway address<\/li>\n<li>Network name<\/li>\n<li>Route-target attached to this network<\/li>\n<li>Project name (collected from openstack horizon GUI)<\/li>\n<li>Token-id (as explained in previous step)<\/li>\n<\/ul>\n<p>To create virtual network ,the RESAPI command &#8220;\/virtual-networks&#8221; is executed on the contrail controller.Port number 8082 is used for this.The correct project name should be added here where it says &#8220;PROJECTNAME&#8221;.\u201dnova net-list\u201d shows the network created as shown below.<\/p>\n<pre><span style=\"font-family: 'courier new', courier;\">$netname=\"net$i\";\n\t\t$cont_ip=\u201d1.1.1.1\u201d;\n\t\t$target=\"target:64512:$value\";\n\t\t$gateway=\"100.$n.$m.1\";\n\t\t$pool = \"100.$n.$m.0\";\n       \t\t $CMDpath = \"\/virtual-networks\";\n        \t\t$APIport=\"8082\";\n       \t\t $url= \"http:\/\/\".$cont_ip.\":\".$APIport.$CMDpath;\n          \t\t$body =\n              \t\t{\n               \t\t\t\"virtual-network\"=&gt;\n                 \t\t\t  {\n                  \t\t\t\t \"parent_type\"=&gt; \"project\",\n                 \t\t\t\t  \"fq_name\"=&gt; [\n                             \t\t\t \"default-domain\",\n                              \t\t\t \"PROJECTNAME\",\n                              \t\t\t  \t$netname ],\n\n                    \t\t\t\"route_target_list\"=&gt;\n                               \t\t {\n                                \t\t\t \"route_target\"=&gt; [\n\t\t\t\t\t\t\t\t$target\n\t\t\t\t\t\t\t      ]\n\t\t\t\t  },\n\n\t\t\t\t\"network_ipam_refs\"=&gt; [{\n                                         \t\t\t\t\t  \"attr\"=&gt; {\n                                                 \t\t\t\t   \t  \"ipam_subnets\"=&gt; [{\n                                                                 \t\t\t\t     \"subnet\"=&gt; {\n                                                                                \t  \t \"gateway_ip\" =&gt; $gateway,\n                                                                                 \t\t \"ip_prefix\"=&gt; $pool,\n                                                                                 \t\t\"ip_prefix_len\"=&gt; 24}}]},\n                                          \t\t\t\t\t  \"to\"=&gt; [\n                                                \t\t\t\t     \t\"default-domain\",\n                                                    \t\t\t\t     \t\"default-project\",\n                                                      \t\t\t\t \"default-network-ipam\"]}]}\n            \t\t\t   };\n\n\t\t$request  = HTTP::Request-&gt;new( POST =&gt; $url );\n        \t\t$bjson = encode_json $body;\n       \t \t$request-&gt;content_type(\"application\/json\");\n       \t \t$request-&gt;header('x-auth-token' =&gt; $token_id);\n       \t \t$request-&gt;content($bjson);\n        \t\t$http = LWP::UserAgent-&gt;new-&gt;request($request);\n\nroot@server1:~# nova net-list\n+--------------------------------------+-------------------------+------+\n| ID                                   | Label                   | CIDR |\n+--------------------------------------+-------------------------+------+\n| 363b4323-69d3-404a-b7b2-6587b4507479 | net6                    | None |\n| 274b0b81-52be-48f9-8888-0c6be1d910c2 | net9                    | None |\n| 72f26b86-f0bf-44c0-aadb-5f94c34b5eeb | net4                    | None |\n| 72be70e4-c0d8-46ce-be8c-33d80f095c5a | default-virtual-network | None |\n| aa0f528e-f276-4d5a-a02f-bb02f7289c9c | net10                   | None |\n| ce1e9035-9c4d-49de-a867-2f4a27bd5691 | net13                   | None |\n| b8599366-f1c0-4c2f-bab2-34533902466d | net12                   | None |\n| b8543c48-872d-4e25-9de7-658f304c032a | net7                    | None |\n| 34168c65-a4c8-439a-beda-3c7a1f380176 | net3                    | None |\n| 7a244326-fc1e-416c-98fb-cc073f8762a0 | test                    | None |\n| e7b4e0b9-6fc9-497f-9899-4e2aa344a97b | net11                   | None |\n| d669a490-53f4-4fac-bed2-b79fe8538eae | __link_local__          | None |\n| f5307953-9490-4da6-b365-7173035d69d3 | net5                    | None |\n| a9eac604-a634-43df-8b9f-ea7258941313 | net8                    | None |\n| a8363373-548d-4f78-8366-bd0277be8b80 | net1                    | None |\n| c4d757cb-d2ab-4334-8e80-029cb0c31610 | ip-fabric               | None |\n| fac53b08-59e7-45c6-9ef6-6007160979bb | net2                    | None |\n+--------------------------------------+-------------------------+------+\nroot@ server1:~# <\/span><\/pre>\n<p><strong>VM Flavor id\/VM Image id\/virtual Network id Details:<\/strong><\/p>\n<p>Before creating the VM we need the following information.There are separate RESTAPI commands available to collect each of this information.<\/p>\n<ul>\n<li>VM name<\/li>\n<li>VM flavor id<\/li>\n<li>VM image id<\/li>\n<li>Virtual network id<\/li>\n<li>VM security group<\/li>\n<li>Tenant name( or project name)<\/li>\n<\/ul>\n<p><strong>VM Flavor id:<\/strong><\/p>\n<p>To get the VM flavor id the following code is used.The RESTAPI command &#8220;\/v1.1\/&#8221;.$tenant_id.&#8221;\/flavors&#8221; returns the VM flavor id.This RESTAPI command is handled by NOVA component of OpenStack controller.<\/p>\n<pre><span style=\"font-family: 'courier new', courier;\">My $NOVAport         =  \"8774\";\n           My $openstack_ip        =\u201d1.1.1.1\u201d;\n\tmy $headers = \"{ 'Content-Type' : 'application\/json', 'Accept'  :  'application\/json' , 'ser-Agent'  : 'python-novaclient', 'X-Auth-Token'   :    $token_id}\";\n        $CMDpath= \"\/v1.1\/\".$tenant_id.\"\/flavors\";\n        $APIport=$NOVAport;\n        $url= \"http:\/\/\". $openstack_ip.\":\".$APIport.$CMDpath;\n        $request  = HTTP::Request-&gt;new( GET =&gt; $url );\n        $request-&gt;header('content-type' =&gt; 'application\/json');\n        $request-&gt;header('x-auth-token' =&gt; $token_id);\n        $http = LWP::UserAgent-&gt;new-&gt;request($request);\n        @y = $http-&gt;{_content};\n        $mes         = JSON::decode_json($y[0]);\n        my $len = @{$mes-&gt;{'flavors'}};\n        my $flavor_id;\n        for (my $x = 0; $x&lt; $len ; ++$x) { if ($mes-&gt;{'flavors'}[$x]{'name'} eq $add_vm_flavor) {\n                        $flavor_id = $mes-&gt;{'flavors'}[$x]{'id'};\n                        last;\n                }\n        }\n        print ( \"\\n\\n *******  image id for $add_vm_flavor is $flavor_id ******* \\n\\n\");<\/span><\/pre>\n<p><strong>VM image id:<\/strong><\/p>\n<p>To get the image id this code is used.The RESTAPI command &#8220;\/v1.1\/&#8221;.$tenant_id.&#8221;\/images&#8221;returns the image id.This RESTAPI command is handled by NOVA component of openstack controller.<\/p>\n<pre><span style=\"font-family: 'courier new', courier;\">my $headers = \"{ 'Content-Type' : 'application\/json', 'Accept'  :  'application\/json' , 'ser-Agent'  : 'python-novaclient', 'X-Auth-Token'   :    $token_id}\";\n        $CMDpath= \"\/v1.1\/\".$tenant_id.\"\/images\";\n        $APIport=$NOVAport;\n        $url= \"http:\/\/\".$cont_ip.\":\".$APIport.$CMDpath;\n        $request  = HTTP::Request-&gt;new( GET =&gt; $url );\n        $request-&gt;header('content-type' =&gt; 'application\/json');\n        $request-&gt;header('x-auth-token' =&gt; $token_id);\n        $http = LWP::UserAgent-&gt;new-&gt;request($request);\n        @y = $http-&gt;{_content};\n        $mes         = JSON::decode_json($y[0]);\n        my $len = @{$mes-&gt;{'images'}};\n        my $image_id;\n        for (my $x = 0; $x&lt; $len ; ++$x) { if ($mes-&gt;{'images'}[$x]{'name'} eq $add_vm_image ) {\n                        $image_id = $mes-&gt;{'images'}[$x]{'id'};\n                        last;\n                }\n        }\n        print (\"\\n\\n *******  image id for $add_vm_image is $image_id ******* \\n\\n\");<\/span><\/pre>\n<p><strong>Virtual Network ID:<\/strong><\/p>\n<p>The RESTAPI command &#8220;\/v1.1\/&#8221;.$tenant_id.&#8221;\/os-tenant-networks&#8221; returns the virtual network id.This RESTAPI command is handled by NOVA component of openstack controller.The network id of the networkname \u201c$add_vm_net\u201d can be identified by this code.<\/p>\n<pre><span style=\"font-family: 'courier new', courier;\">my $headers = \"{ 'Content-Type' : 'application\/json', 'Accept'  :  'application\/json' , 'ser-Agent'  : 'python-novaclient', 'X-Auth-Token'   :    $token_id}\";\n        $CMDpath= \"\/v1.1\/\".$tenant_id.\"\/os-tenant-networks\";\n        $APIport=$NOVAport;\n        $url= \"http:\/\/\".$cont_ip.\":\".$APIport.$CMDpath;\n        $request  = HTTP::Request-&gt;new( GET =&gt; $url );\n        $request-&gt;header('content-type' =&gt; 'application\/json');\n        $request-&gt;header('x-auth-token' =&gt; $token_id);\n        $http = LWP::UserAgent-&gt;new-&gt;request($request);\n        @y = $http-&gt;{_content};\n        $mes         = JSON::decode_json($y[0]);\n        my $len = @{$mes-&gt;{'networks'}};\n        my $network_id;\n        for (my $x = 0; $x&lt; $len ; ++$x) { if ($mes-&gt;{'networks'}[$x]{'label'} eq $add_vm_net ) {\n                        $network_id = $mes-&gt;{'networks'}[$x]{'id'};\n                        last;\n                }\n        }\n        print (\"\\n\\n *******  networks id for $add_vm_net is $network_id ******* \\n\\n\");<\/span><\/pre>\n<p><strong>VM creation:<\/strong><\/p>\n<p>Now we reached the final step to create VM.The RESTAPI &#8220;\/v1.1\/&#8221;.$tenant_id.&#8221;\/servers&#8221; creates the VM.<\/p>\n<p>The VM name,image id ,flavor id and security group name are required to run this RESTAPI command.<\/p>\n<pre><span style=\"font-family: 'courier new', courier;\">$headers = \"{ 'Content-Type' : 'application\/json', 'Accept' : 'application\/json', 'ser-Agent' : 'python-novaclient', 'X-OpenStack-Nova-API-Version': '2.11', 'X-Auth-Token' : $token_id}\";\n        $CMDpath = \"\/v1.1\/\".$tenant_id.\"\/servers\";\n        $APIport=$NOVAport;\n        $url= \"http:\/\/\".$cont_ip.\":\".$APIport.$CMDpath;\n        $body =\n        {       \"server\" =&gt;\n                         {\n                                \"name\" =&gt; \"$add_vm_name\",\n                                \"imageRef\" =&gt; \"$image_id\",\n                                \"flavorRef\" =&gt; \"$flavor_id\",\n                                \"max_count\" =&gt; 1,\n                                \"min_count\" =&gt; 1,\n                                \"networks\" =&gt; [{\n                                                \"uuid\" =&gt; \"$network_id\"\n                                }],\n                                \"security_groups\" =&gt; [{\n                                                \"name\" =&gt; \"$add_vm_secgroup\"\n                                }]\n                        }\n        };\n        $request  = HTTP::Request-&gt;new( POST =&gt; $url );\n        $bjson = encode_json $body;\n        $request-&gt;content_type(\"application\/json\");\n        $request-&gt;header('x-auth-token' =&gt; $token_id);\n        $request-&gt;content($bjson);\n        $http = LWP::UserAgent-&gt;new-&gt;request($request);<\/span><\/pre>\n<p><strong>VM status verification:<\/strong><\/p>\n<p>After creating VM the status of the VM can be verified by the RESTAPI command &#8220;\/v1.1\/&#8221;.$tenant_id.&#8221;\/servers\/detail&#8221;.This sample code gives details on how to verify status of a VM.It checks for vm_state to be active and power_state to be 1.This RESTAPI command is equivalent to nova list command shown below.<\/p>\n<pre><span style=\"font-family: 'courier new', courier;\">$CMDpath= \"\/v1.1\/\".$tenant_id.\"\/servers\/detail\";\n        $APIport=$NOVAport;\n        $url= \"http:\/\/\".$cont_ip.\":\".$APIport.$CMDpath;\n        $request  = HTTP::Request-&gt;new( GET =&gt; $url );\n        $request-&gt;header('content-type' =&gt; 'application\/json');\n        $request-&gt;header('x-auth-token' =&gt; $token_id);\n        $http = LWP::UserAgent-&gt;new-&gt;request($request);\n        @y = $http-&gt;{_content};\n        print Dumper($http);\n        $mes         = JSON::decode_json($y[0]);\n        my $len = @{$mes-&gt;{\"servers\"}};\n        my %server_to_netaddr_hash;\n        my %test;\n        my $servername;\n        my $state;\n        my $status;\n        my $test;\n        my $vmcount=0;\n\n\t$status = $mes-&gt;{\"servers\"}[$x]{\"OS-EXT-STS:vm_state\"};\n          $state = $mes-&gt;{\"servers\"}[$x]{\"OS-EXT-STS:power_state\"};\n          if ( $status ne \"active\" || $state != 1) {\n        print (\"\\n\\n *******  status\/state  of the vm $test is not correct.The current  status is $status and state is $state ******* \\n\\n\");\n         return JT::FALSE;\n                        }\n        print (\"\\n\\n *******  status and state  of the vm $test is correct The current status is $status and state is $state******* \\n\\n\");\n\n                     }\n\nroot@ server1:~# nova list\n+--------------------------------------+--------+--------+------------+-------------+--------------------+\n| ID                                   | Name   | Status | Task State | Power State | Networks           |\n+--------------------------------------+--------+--------+------------+-------------+--------------------+\n| 935bb371-9fb6-4d1e-92b6-239db2d28a2a | nvmg1  | ACTIVE | -          | Running     | net1=100.0.4.252   |\n| 69b9dca5-a4e0-4168-8363-b87caa65e741 | nvmg10 | ACTIVE | -          | Running     | net10=100.0.13.252 |\n| 176f9b62-1561-41e9-9c2f-de86f76afffd | nvmg11 | ACTIVE | -          | Running     | net11=100.0.14.252 |\n| 15eff465-7251-4de8-b371-cc85790ca9a6 | nvmg12 | ACTIVE | -          | Running     | net12=100.0.15.252 |\n| c1be1e20-4969-4911-8fdf-81e09c0023e9 | nvmg13 | ACTIVE | -          | Running     | net13=100.0.16.252 |\n| 449becae-69b7-4f57-947a-74d78875ef39 | nvmg2  | ACTIVE | -          | Running     | net2=100.0.5.252   |\n| db8c1d5b-5990-458f-bfcb-13a7d2bdbbda | nvmg3  | ACTIVE | -          | Running     | net3=100.0.6.252   |\n| a7ceee7e-539a-4398-a768-209db065a71c | nvmg4  | ACTIVE | -          | Running     | net4=100.0.7.252   |\n| 43713c5b-c262-4e56-9a77-ffde968f448e | nvmg5  | ACTIVE | -          | Running     | net5=100.0.8.252   |\n| 8010f8a0-56d8-4904-a747-8e5dfa1f8ac8 | nvmg6  | ACTIVE | -          | Running     | net6=100.0.9.252   |\n| 0c57cb78-922b-4f76-98d5-f962f08a85a6 | nvmg7  | ACTIVE | -          | Running     | net7=100.0.10.252  |\n| 47ca6427-c898-4d71-9c2d-61ffa533e31e | nvmg8  | ACTIVE | -          | Running     | net8=100.0.11.252  |\n| a08bbaac-3ed9-4cf6-ad6c-def7484a35e4 | nvmg9  | ACTIVE | -          | Running     | net9=100.0.12.252  |\n+--------------------------------------+--------+--------+------------+-------------+--------------------+\n<\/span><\/pre>\n<p>The status of the VMs can also be checked in OPENSTACK horizon GUI as shown below.<\/p>\n<p><a href=\"http:\/\/www.opencontrail.org\/wp-content\/uploads\/2017\/01\/Automating_Contrail_Cloud_Platform_Image3.jpg\"><img loading=\"lazy\" decoding=\"async\" class=\"alignnone wp-image-7282\" src=\"http:\/\/www.opencontrail.org\/wp-content\/uploads\/2017\/01\/Automating_Contrail_Cloud_Platform_Image3.jpg\" width=\"1059\" height=\"600\" data-id=\"7282\" \/><\/a><\/p>\n<p><strong>VM Deletion:<\/strong><\/p>\n<p>Before start deleting the VMs we need to get the token-id from the Openstack server using the procedure given earlier.In addition to this we need to know the VM id.To get the VM id we can use the RESTAPI &#8220;\/v2\/&#8221;.$tenant_id.&#8221;\/servers?name=&#8221;.$del_vm_name as shown below.<\/p>\n<pre><span style=\"font-family: 'courier new', courier;\">my $headers = \"{ 'Content-Type' : 'application\/json', 'Accept'  :  'application\/json' , 'ser-Agent'  : 'python-novaclient', 'X-Auth-Token'   :    $token_id}\";\n        $CMDpath= \"\/v2\/\".$tenant_id.\"\/servers?name=\".$del_vm_name;\n        $APIport=$NOVAport;\n        $url= \"http:\/\/\".$cont_ip.\":\".$APIport.$CMDpath;\n        $request  = HTTP::Request-&gt;new( GET =&gt; $url );\n        $request-&gt;header('content-type' =&gt; 'application\/json');\n        $request-&gt;header('x-auth-token' =&gt; $token_id);\n        $http = LWP::UserAgent-&gt;new-&gt;request($request);\n        @y = $http-&gt;{_content};\n        $mes         = JSON::decode_json($y[0]);\n        #print \"\\n\\n\\n\\n\\n\\---------------\\n\\n\\n\\n\";\n        #print Dumper($mes);\n        my $del_vm_id = $mes-&gt;{'servers'}[0]{'id'};\n        print ( \"\\n\\n *******  delte vm instance id is $del_vm_id ******* \\n\\n\");<\/span><\/pre>\n<p>After getting the VM ID we can use the RESTAPI &#8220;\/v1.1\/&#8221;.$tenant_id.&#8221;\/servers\/&#8221;.$del_vm_id.&#8221;\/action&#8221; to delete the VM.This is equivlant to \u201cnova delete &lt;vm name\/vm id&gt;\u201d command.<\/p>\n<pre><span style=\"font-family: 'courier new', courier;\">$headers = \"{ 'Content-Type' : 'application\/json', 'Accept'  :  'application\/json' , 'ser-Agent'  : 'python-novaclient', 'X-Auth-Token'   :    $token_id}\";\n        $CMDpath = \"\/v1.1\/\".$tenant_id.\"\/servers\/\".$del_vm_id.\"\/action\";\n        $APIport=$NOVAport;\n        $url= \"http:\/\/\".$cont_ip.\":\".$APIport.$CMDpath;\n        $body =\n        {\n               \"forceDelete\"   =&gt;  \"null\"\n        };\n        $request  = HTTP::Request-&gt;new( POST =&gt; $url );\n        $bjson = encode_json $body;\n        $request-&gt;content_type(\"application\/json\");\n        $request-&gt;header('x-auth-token' =&gt; $token_id);\n        $request-&gt;content($bjson);\n        $http = LWP::UserAgent-&gt;new-&gt;request($request);<\/span><\/pre>\n<h3>Conclusion<\/h3>\n<p>This document gives details on CONTRAIL cloud solution implementation. It also explains the RESTAPI details for\u00a0 VM creation,VM deletion etc..<\/p>\n<h3>APPENDIX<\/h3>\n<p>The section give details on other RESTAPI commands.<\/p>\n<h4>Deleting virtual network:<\/h4>\n<p>This command is executed on the contrail controller. To run this command\u00a0we need virtual network id.<\/p>\n<pre><span style=\"font-family: 'courier new', courier;\">$CMDpath = \"\/virtual-network\/\";\n        $APIport=\"8082\";\n        $url= \"http:\/\/\".$cont_ip.\":\".$APIport.$CMDpath.$netid;\n        $request  = HTTP::Request-&gt;new( DELETE =&gt; $url );\n       $request-&gt;header('content-type' =&gt; 'application\/json');\n        $request-&gt;header('x-auth-token' =&gt; $token_id);\n        $http = LWP::UserAgent-&gt;new-&gt;request($request);<\/span><\/pre>\n<p>To get the virtual network id this RESTAPI is used.The \u201cuuid\u201d returns the network id.<\/p>\n<pre><span style=\"font-family: 'courier new', courier;\">$CMDpath = \"\/virtual-networks\";\n        $APIport=\"8082\";\n        $url= \"http:\/\/\".$cont_ip.\":\".$APIport.$CMDpath;\n        $request  = HTTP::Request-&gt;new( GET =&gt; $url );\n        $request-&gt;content_type(\"application\/json\");\n        $request-&gt;header('x-auth-token' =&gt; $token_id);\n        $http = LWP::UserAgent-&gt;new-&gt;request($request);\n         print Dumper $http;\n          @y = $http-&gt;{_content};\n        $mes         = JSON::decode_json($y[0]);\n          $len = @{$mes-&gt;{\"virtual-networks\"}};\n        my @network_list;\n        my $i=1;\n        for (my $x = 0; $x&lt; $len ; ++$x) { if ($mes-&gt;{\"virtual-networks\"}[$x]{\"fq_name\"}[2]  =~ \/net\\d+\/) {\n                push (@network_list, $mes-&gt;{\"virtual-networks\"}[$x]{\"uuid\"});\n                $i++;\n            }\n          }<\/span><\/pre>\n<p>To delete the ports which map virtual network with the VM we need to use the RESTAPI given below.<\/p>\n<p>We need portid to run this command.<\/p>\n<pre><span style=\"font-family: 'courier new', courier;\">My $NEUTRONport      =  \"9696\";\n         $CMDpath = \"\/v2.0\/ports\/\";\n        $APIport=$NEUTRONport;\n        $url= \"http:\/\/\".$cont_ip.\":\".$APIport.$CMDpath.$portid.\".json\";\n        $request  = HTTP::Request-&gt;new( DELETE =&gt; $url );\n       $request-&gt;header('content-type' =&gt; 'application\/json');\n        $request-&gt;header('x-auth-token' =&gt; $token_id);\n        $http = LWP::UserAgent-&gt;new-&gt;request($request);<\/span><\/pre>\n<p>The port id can be found from,<\/p>\n<pre><span style=\"font-family: 'courier new', courier;\">$CMDpath= \"\/v2.0\/ports.json\";\n        $APIport=$NEUTRONport;\n        $url= \"http:\/\/\".$cont_ip.\":\".$APIport.$CMDpath;\n        $request  = HTTP::Request-&gt;new( GET =&gt; $url );\n        $request-&gt;header('content-type' =&gt; 'application\/json');\n        $request-&gt;header('x-auth-token' =&gt; $token_id);\n        $http = LWP::UserAgent-&gt;new-&gt;request($request);\n        @y = $http-&gt;{_content};\n        $mes         = JSON::decode_json($y[0]);\n        my $len = @{$mes-&gt;{\"ports\"}};\n        my @port_list;\n        for (my $x = 0; $x&lt; $len ; ++$x) { push (@port_list, $mes-&gt;{\"ports\"}[$x]{\"id\"});\n        }<\/span><\/pre>\n","protected":false},"excerpt":{"rendered":"<p>Executive summary: Contrail Cloud solution is an open cloud network automation product that uses\u00a0software-defined networking (SDN)\u00a0technology to orchestrate the creation of virtual networks with high scalability. It exposes a set&#8230;<\/p>\n","protected":false},"author":494,"featured_media":0,"comment_status":"open","ping_status":"closed","sticky":false,"template":"","format":"standard","meta":{"footnotes":""},"categories":[5,30,7,20],"tags":[],"acf":[],"yoast_head":"<!-- This site is optimized with the Yoast SEO plugin v21.6 - https:\/\/yoast.com\/wordpress\/plugins\/seo\/ -->\n<title>Automating Contrail Cloud Solution - Tungsten Fabric<\/title>\n<meta name=\"robots\" content=\"index, follow, max-snippet:-1, max-image-preview:large, max-video-preview:-1\" \/>\n<link rel=\"canonical\" href=\"https:\/\/tungsten.io\/automating-contrail-cloud-solution\/\" \/>\n<meta property=\"og:locale\" content=\"en_US\" \/>\n<meta property=\"og:type\" content=\"article\" \/>\n<meta property=\"og:title\" content=\"Automating Contrail Cloud Solution - Tungsten Fabric\" \/>\n<meta property=\"og:description\" content=\"Executive summary: Contrail Cloud solution is an open cloud network automation product that uses\u00a0software-defined networking (SDN)\u00a0technology to orchestrate the creation of virtual networks with high scalability. It exposes a set...\" \/>\n<meta property=\"og:url\" content=\"https:\/\/tungsten.io\/automating-contrail-cloud-solution\/\" \/>\n<meta property=\"og:site_name\" content=\"Tungsten Fabric\" \/>\n<meta property=\"article:published_time\" content=\"2017-01-09T00:03:24+00:00\" \/>\n<meta property=\"og:image\" content=\"http:\/\/www.opencontrail.org\/wp-content\/uploads\/2017\/01\/Automating_Contrail_Cloud_Platform_Image1.jpg\" \/>\n<meta name=\"author\" content=\"Ramanathan Sethuraman\" \/>\n<meta name=\"twitter:card\" content=\"summary_large_image\" \/>\n<script type=\"application\/ld+json\" class=\"yoast-schema-graph\">{\"@context\":\"https:\/\/schema.org\",\"@graph\":[{\"@type\":\"WebPage\",\"@id\":\"https:\/\/tungsten.io\/automating-contrail-cloud-solution\/\",\"url\":\"https:\/\/tungsten.io\/automating-contrail-cloud-solution\/\",\"name\":\"Automating Contrail Cloud Solution - Tungsten Fabric\",\"isPartOf\":{\"@id\":\"https:\/\/tungsten.io\/#website\"},\"datePublished\":\"2017-01-09T00:03:24+00:00\",\"dateModified\":\"2017-01-09T00:03:24+00:00\",\"author\":{\"@id\":\"https:\/\/tungsten.io\/#\/schema\/person\/6abcec47540d75712e1a8092014691d7\"},\"inLanguage\":\"en-US\",\"potentialAction\":[{\"@type\":\"ReadAction\",\"target\":[\"https:\/\/tungsten.io\/automating-contrail-cloud-solution\/\"]}]},{\"@type\":\"WebSite\",\"@id\":\"https:\/\/tungsten.io\/#website\",\"url\":\"https:\/\/tungsten.io\/\",\"name\":\"Tungsten Fabric\",\"description\":\"multicloud multistack SDN\",\"potentialAction\":[{\"@type\":\"SearchAction\",\"target\":{\"@type\":\"EntryPoint\",\"urlTemplate\":\"https:\/\/tungsten.io\/?s={search_term_string}\"},\"query-input\":\"required name=search_term_string\"}],\"inLanguage\":\"en-US\"},{\"@type\":\"Person\",\"@id\":\"https:\/\/tungsten.io\/#\/schema\/person\/6abcec47540d75712e1a8092014691d7\",\"name\":\"Ramanathan Sethuraman\",\"image\":{\"@type\":\"ImageObject\",\"inLanguage\":\"en-US\",\"@id\":\"https:\/\/tungsten.io\/#\/schema\/person\/image\/\",\"url\":\"https:\/\/secure.gravatar.com\/avatar\/bf6221ae7518a72f5bebceda7ebc8a4a?s=96&d=mm&r=pg\",\"contentUrl\":\"https:\/\/secure.gravatar.com\/avatar\/bf6221ae7518a72f5bebceda7ebc8a4a?s=96&d=mm&r=pg\",\"caption\":\"Ramanathan Sethuraman\"},\"url\":\"https:\/\/tungsten.io\"}]}<\/script>\n<!-- \/ Yoast SEO plugin. -->","yoast_head_json":{"title":"Automating Contrail Cloud Solution - Tungsten Fabric","robots":{"index":"index","follow":"follow","max-snippet":"max-snippet:-1","max-image-preview":"max-image-preview:large","max-video-preview":"max-video-preview:-1"},"canonical":"https:\/\/tungsten.io\/automating-contrail-cloud-solution\/","og_locale":"en_US","og_type":"article","og_title":"Automating Contrail Cloud Solution - Tungsten Fabric","og_description":"Executive summary: Contrail Cloud solution is an open cloud network automation product that uses\u00a0software-defined networking (SDN)\u00a0technology to orchestrate the creation of virtual networks with high scalability. It exposes a set...","og_url":"https:\/\/tungsten.io\/automating-contrail-cloud-solution\/","og_site_name":"Tungsten Fabric","article_published_time":"2017-01-09T00:03:24+00:00","og_image":[{"url":"http:\/\/www.opencontrail.org\/wp-content\/uploads\/2017\/01\/Automating_Contrail_Cloud_Platform_Image1.jpg"}],"author":"Ramanathan Sethuraman","twitter_card":"summary_large_image","schema":{"@context":"https:\/\/schema.org","@graph":[{"@type":"WebPage","@id":"https:\/\/tungsten.io\/automating-contrail-cloud-solution\/","url":"https:\/\/tungsten.io\/automating-contrail-cloud-solution\/","name":"Automating Contrail Cloud Solution - Tungsten Fabric","isPartOf":{"@id":"https:\/\/tungsten.io\/#website"},"datePublished":"2017-01-09T00:03:24+00:00","dateModified":"2017-01-09T00:03:24+00:00","author":{"@id":"https:\/\/tungsten.io\/#\/schema\/person\/6abcec47540d75712e1a8092014691d7"},"inLanguage":"en-US","potentialAction":[{"@type":"ReadAction","target":["https:\/\/tungsten.io\/automating-contrail-cloud-solution\/"]}]},{"@type":"WebSite","@id":"https:\/\/tungsten.io\/#website","url":"https:\/\/tungsten.io\/","name":"Tungsten Fabric","description":"multicloud multistack SDN","potentialAction":[{"@type":"SearchAction","target":{"@type":"EntryPoint","urlTemplate":"https:\/\/tungsten.io\/?s={search_term_string}"},"query-input":"required name=search_term_string"}],"inLanguage":"en-US"},{"@type":"Person","@id":"https:\/\/tungsten.io\/#\/schema\/person\/6abcec47540d75712e1a8092014691d7","name":"Ramanathan Sethuraman","image":{"@type":"ImageObject","inLanguage":"en-US","@id":"https:\/\/tungsten.io\/#\/schema\/person\/image\/","url":"https:\/\/secure.gravatar.com\/avatar\/bf6221ae7518a72f5bebceda7ebc8a4a?s=96&d=mm&r=pg","contentUrl":"https:\/\/secure.gravatar.com\/avatar\/bf6221ae7518a72f5bebceda7ebc8a4a?s=96&d=mm&r=pg","caption":"Ramanathan Sethuraman"},"url":"https:\/\/tungsten.io"}]}},"_links":{"self":[{"href":"https:\/\/tungsten.io\/wp-json\/wp\/v2\/posts\/7279"}],"collection":[{"href":"https:\/\/tungsten.io\/wp-json\/wp\/v2\/posts"}],"about":[{"href":"https:\/\/tungsten.io\/wp-json\/wp\/v2\/types\/post"}],"author":[{"embeddable":true,"href":"https:\/\/tungsten.io\/wp-json\/wp\/v2\/users\/494"}],"replies":[{"embeddable":true,"href":"https:\/\/tungsten.io\/wp-json\/wp\/v2\/comments?post=7279"}],"version-history":[{"count":0,"href":"https:\/\/tungsten.io\/wp-json\/wp\/v2\/posts\/7279\/revisions"}],"wp:attachment":[{"href":"https:\/\/tungsten.io\/wp-json\/wp\/v2\/media?parent=7279"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"https:\/\/tungsten.io\/wp-json\/wp\/v2\/categories?post=7279"},{"taxonomy":"post_tag","embeddable":true,"href":"https:\/\/tungsten.io\/wp-json\/wp\/v2\/tags?post=7279"}],"curies":[{"name":"wp","href":"https:\/\/api.w.org\/{rel}","templated":true}]}}